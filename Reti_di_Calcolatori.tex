\documentclass{article}

\usepackage{cancel}
\usepackage{amsmath}
\usepackage[includehead,nomarginpar]{geometry}
\usepackage{graphicx}
\usepackage{amsfonts} 
\usepackage{verbatim}
\usepackage{mathrsfs}  
\usepackage{lmodern}
\usepackage{braket}
\usepackage{bookmark}
\usepackage{fancyhdr}
\usepackage{romanbarpagenumber}
\usepackage{minted}
%\usepackage{subfig}
\usepackage[italian]{babel}
\usepackage{float}
%\usepackage{wrapfig}
%\usepackage[export]{adjustbox}
\usepackage[dvipsnames]{xcolor}
\allowdisplaybreaks

\setlength{\headheight}{12.0pt}
\addtolength{\topmargin}{-12.0pt}
\graphicspath{ {./Immagini/} }

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    pdftitle={Appunti di Reti di Calcolatori},
    pdfauthor={Giacomo Sturm},
    pdfsubject={Reti di Calcolatori Approccio Bottom Up},
    pdfkeywords={Network, Reti di Calcolatori, Roma Tre}
}

\newsavebox{\tempbox} %{\raisebox{\dimexpr.5\ht\tempbox-.5\height\relax}}


\makeatother

\numberwithin{equation}{subsection}
\newcommand{\tageq}{\tag{\stepcounter{equation}\theequation}}
\AtBeginDocument{%
  \renewcommand{\figurename}{Fig.}
}
\fancypagestyle{link}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}\fancyfoot[C]{Sorgente del \textit{file} \LaTeX$\,\,$disponibile al seguente link: \url{https://github.com/00Darxk/Reti-di-Calcolatori/}}}

\begin{document}

\title{%
    \textbf{Reti di Calcolatori}  \\ 
    \large Appunti delle Lezioni di Reti di Calcolatori \\
    \textit{Anno Accademico: 2024/25}}
\author{\textit{Giacomo Sturm}}
\date{\textit{Dipartimento di Ingegneria Civile, Informatica e delle Tecnologie Aeronautiche \\
Università degli Studi ``Roma Tre"}}

\maketitle
\thispagestyle{link}
\clearpage


\pagestyle{fancy}
\fancyhead{}\fancyfoot{}
\fancyhead[C]{\textit{Reti di Calcolatori - Università degli Studi ``Roma Tre"}}
\fancyfoot[C]{\thepage}
\pagenumbering{Roman}

\tableofcontents


\clearpage
\pagenumbering{arabic}


%% TODO acronimi maiuscolo: minuscolo: \textit{}, parole inglesi o def acronimi \textit{}
%% https://mirrors.ibiblio.org/CTAN/graphics/pgf/contrib/tikz-network/tikz-network.pdf, per immagini di reti a più livelli (?)

\section{Introduzione}

Una qualsiasi interconnessione di calcolatori può rappresentare una rete di calcolatori, ma in base alla distanza reciproca tra questi componenti 
si tratta di reti differenti. Convenzionalmente si considerano reti di calcolatori, sistemi di calcolatori interconnessi ad una distanza 
superiore ai 50 cm. Una distanza minore, fino ai 5 cm, generalmente interessa componenti dello stesso computer, sulla stessa scheda madre, connesse tra di loro; mentre una 
distanza inferiore ai 5 cm rappresenta componenti sullo stesso chip. Inoltre le reti considerate possono essere ulteriormente divise in base 
alla distanza dei loro elementi:
\begin{itemize}
    \item Se hanno una distanza minore di 5 km, si tratta di risorse connesse sulla stessa rete o edificio, o su edifici vicini. Questo tipo di rete si chiama \textit{Local Area Network} (\textcolor{violet}{LAN});
    \item Se hanno una distanza superiore ai 5 km, si tratta di risorse connesse su una vasta area geografica. Questo tipo di rete si chiama \textit{Wide Area Network} (\textcolor{purple}{WAN}).
\end{itemize}
Tra questi due livelli possono essere presenti anche tecnologie molto diverse tra di loro, queste tecnologie vengono identificate da acronimi da cui 
è possibile ricavare lo scopo della tecnologia, senza tuttavia conoscere il suo funzionamento. 

Una connessione tra componenti di una rete coinvolge sempre uno scambio di informazioni, tramite uno scambio di messaggi in serie. Gli elementi della 
rete effettuano degli accessi ad essa apparentemente in parallelo e simultanei, per poter comunicare tra di loro. Mentre su componenti sulla stessa macchina o sullo 
stesso chip avvengono tramite accessi ad una memoria condivisa. 

Le connessioni tra componenti di una rete avvengono su uno strato fisico, quindi attraverso diversi mezzi trasmissivi, i quali non verranno analizzati approfonditamente a 
questo livello di astrazione. Tra i più comuni mezzi trasmissivi abbiamo cavi in fibra ottica, o in rame, ed onde radio. 

\subsection{Commutazione}

Una rete di calcolatori può essere rappresentata come un grafo composto da vari nodi, per realizzare tutte le possibili coppie di calcolatori che potrebbero comunicare 
tra di loro attraverso la rete. Ma se venissero collegati individualmente tutte le possibili coppie di calcolatori necessiterebbe di infrastrutture massicce, poiché 
il numero dei possibili percorsi aumenta quadraticamente rispetto all'aumento dei calcolatori della rete. Infatti avendo $n$, tutte le possibili combinazioni tra 
questi calcolatori sono $n(n-2)/2$, nel caso ognuna di queste coppie corrisponda ad una connessione differente, il costo di costruzione e gestione della rete 
sarebbe eccessivo. 

Per risolvere questo problema e diminuire il numero totale di connessioni nella rete si utilizza il meccanismo della commutazione. Questo termine risale alla telefonia, 
dove sorse lo stesso problema, risolto introducendo centralini intermedi dove si potevano collegare diverse area telefoniche contenenti i telefoni che tentavano 
di comunicare. In questo modo si può drasticamente diminuire il numero di connessioni individuali nella rete, e non bisogna integrare un numero elevato di connessioni 
all'aggiunta di un singolo elemento. 
Si indica quindi con commutazione di circuito questo meccanismo di creare una connessione fisica tra due calcolatori, connettendo diverse zone 
della rete attraverso nodi intermedi. 
\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Commutazione di Circuito}%
\end{figure}

L'interazione tra computer consiste intrinsecamente da grandi quantità di dati trasmessi velocemente a grandi distanze, per cui 
hanno bisogno di infrastrutture dedicate massicce, si preferisce quindi questo sistema di nodi intermedi, nonostante non consenta di soddisfare contemporaneamente 
tutte le coppie di calcolatori. 

Poiché questa grande quantità di dati deve attraversare la rete velocemente, si utilizza una diversa tecnica di comunicazione a livello dei singoli messaggi, dividendoli 
in pacchetti da spedire separatamene. Nella commutazione a datagramma questi pacchetti vengono spediti su linee anche diverse e si mescolano a tutti i pacchetti che 
attraversano quel percorso. Le linee non sono quindi ad uso esclusivo di una singola connessione. 
\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Commutazione di Pacchetto a Datagramma}%  
\end{figure}
Ma per ricomporre il messaggio originale bisogna combinare questi pacchetti nello stesso ordine in cui sono stati separati, sono necessari dati aggiuntivi per 
poter riconoscere il loro ordine, perso durante la trasmissione. La distanza attraversata da ciascun pacchetto infatti non è garantito sia uguale. 

Esiste un altro tipo di commutazione a circuito virtuale, dove i pacchetti vengono inviati sullo stesso percorso sequenzialmente, ed ogni linea può essere 
condivisa da un altro circuito virtuale, quindi non sono ad uso esclusivo. 
\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Commutazione di Pacchetto a Circuito Virtuale}%  
\end{figure}
In questo caso invece è necessario un meccanismo per poter distinguere tra di loro 
questi circuiti virtuali sulla stessa linea fisica. 

Si è risolto tramite la commutazione di pacchetto l'esclusività delle linee della rete, introdotta dal modello a commutazione di circuito. 


La rete \textit{internet} moderna utilizza la commutazione a datagramma, per motivi economici e gestionali. Altrimenti sarebbe necessario un gestore della rete che deve trovare 
un percorso ed attribuirlo ad una coppia ad ogni tentativo di connessione. Data la complessità della rete moderna, lasciare che i pacchetti trovino il percorso 
autonomamente è la scelta più efficiente. 
Per realizzare una commutazione a datagramma, piccole aree geografiche diverse vengono coperte da \textit{Internet Service Provider} (\textcolor{teal}{ISP}) differenti che possono comunicare 
solamente con altri \textcolor{teal}{ISP} adiacenti. Quindi all'invio di un pacchetto, se il destinatario non è nella stessa zona dell'\textcolor{teal}{ISP} corrente, questo lo invia ad un \textcolor{teal}{ISP} adiacente 
che crede possa contenere il destinatario, così anche per la ricezione da un altro \textcolor{teal}{ISP}. In caso il destinatario sia nella zona dell'\textcolor{teal}{ISP} corrente, questo lo trasmette a lui. 
Accordi possono essere stipulati da chiunque a chiunque, un \textcolor{teal}{ISP} ha sempre la necessità di trasmettere i pacchetti attraverso la rete. 

In certi casi l'\textcolor{teal}{ISP} può gestire la rete a circuito virtuale, se sia il destinatario che il mittente siano coperti dal singolo \textcolor{teal}{ISP}. 

\subsection{Velocità}

Nelle reti \textcolor{violet}{LAN} e \textcolor{purple}{WAN}  si possono trasmettere dati a velocità diverse:

\begin{itemize}
    \item \textcolor{violet}{LAN}: velocità tra 10 ai 100 Mb/s;
    \item \textcolor{purple}{WAN}: velocità tra 64 Kb/s ai 200-400 Mb/s. 
\end{itemize} 

Le reti \textcolor{purple}{WAN} presentano hanno molti livelli di retrocompatibilità mantenuti, per cui si possono trasmettere dati a velocità minori di una rete \textcolor{violet}{LAN}. 
In generale sono sempre richieste reti a velocità di trasmissione elevata, e connessioni ad alta velocità. 

Data una rete si può definire la velocità in due modi differenti. Se si considera il tempo in cui il primo bit del messaggio arriva a destinazione. Le connessioni ad 
alta velocità vengono realizzate in linee a fibra ottica, per cui i bit vengono inviati come impulsi di luce, e viaggiano ad una velocità costante, quindi per ogni rete 
la velocità di trasmissione di un singolo bit è la stessa. Si definisce quindi il tempo di ritardo o \textit{delay}, il tempo per trasmettere un singolo bit, alla velocità della luce, sulla 
rete e dipende interamente dalla distanza. 

Un pacchetto non viene rappresentato da un singolo bit, per cui non possono essere trasmessi alla stessa velocità, si definisce banda la quantità di bit trasmessi 
contemporaneamente sulla linea. Questa si chiama banda, e generalmente è sempre possibile comprare più banda in modo relativamente facile, ma è molto difficile comprare meno \textit{delay}. 

\subsection{Gestione delle Risorse}

La rete è essenzialmente un insieme di risorse interconnesse tra di loro e dalla teoria dei sistemi operativi, il loro controllo può essere descritto da varie attività:
\begin{itemize}
    \item Verifica dei diritti d'accesso;
    \item Sequenziamento degli accessi alla risorsa;
    \item Esecuzione delle operazioni disponibili. 
\end{itemize}

Ad ogni risorsa vengono assegnato almeno un gestore, di numero variabile in base al tipo di gestione. 
Le modalità di gestione delle risorse sono varie, si dividono in gestione autocratica e multilaterale. Nella gestione autocratica ogni risorsa ha un unico gestore 
associato ed univoco. Nella gestione multilaterale per ogni risorsa può esserci più di un gestore, si possono identificare quindi tre sottotipi di questa gestione:
\begin{itemize}
    \item Gestione partizionata, dove attività di gestione viene effettuata da un singolo processo;
    \item Gestione successiva, dove tutte le attività di gestione vengono effettuate a turni da più processi;
    \item Gestione replicata, dove tutti i gestori partecipano a ciascuna attività, se ogni gestore ha peso decisionale uguale allora si tratta di gestione democratica. 
\end{itemize}

La gestione replicata fornisce una forte resistenza ai guasti per un numero elevato di gestori che partecipano a ciascuna istanza di una attività, con alto grado di 
uguaglianza nella responsabilità di gestione. Sono abbastanza diffusi meccanismi di elezione per la scelta dei gestori. 

\clearpage

\section{Modello \textcolor{blue}{ISO-OSI}}

Per il funzionamento della rete gli standard sono strettamente necessari, altrimenti non sarebbe possibile una comunicazione tra un mittente ed un destinatario qualsiasi, 
alcuni di questi standard vengono imposti dalla case costruttrici, altri vengono definiti da organizzazioni internazionali, nell'ambito informatico o delle 
telecomunicazioni. Alcune di queste associazioni come IETF sono indipendenti da stati nazionali, dove varie aziende o istituzioni propongono modifiche di vecchi 
standard o introduzione e definizione di nuovi. 

Il modello \textcolor{blue}{ISO-OSI} rappresenta un importante strumento di classificazione nel modo delle reti. Venne realizzato in parte e sostanzialmente dismesso, ma nonostante 
questo viene utilizzato a livello globale. 

Questo modello si basa sull'architettura stratificata di \textit{hardware} o software, dove partendo da un nucleo centrale il sistema viene diviso in livelli o strati 
indipendenti dal livello inferiore, ed uno strato fornisce servizi solamente allo strato immediatamente superiore. Avanzando da uno strato al superiore i servizi vengono mostrati in modo 
sempre più astratto ed il sistema aumenta progressivamente di utilità. Per la sua utilità questo tipo di architettura stratificata permane molti campi dell'informatica. 

La rete viene divisa in 7 livelli numerati dal basso verso l'alto, il livello indica la funzione delle tecnologie che vi appartengono e questo fornisce uno strumento di 
classificazione per analizzarle senza dover conoscere i loro meccanismi interni:

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Standard \textcolor{blue}{ISO-OSI} ed Internet Protocol Suite}%  
\end{figure}

Ogni strato rappresenta un diverso livello di astrazione ed offrono funzioni ben definite. Poiché ognuno di questi strati è indipendente dal livello inferiore, viene minimizzato lo scambio 
di informazioni tra strati. Il numero dei livelli venne scelto in base alle funzioni distinte di una rete da descrivere e dalla realizzabilità. 

All'interno di ogni strato si possono individuare diverse ``entità'', \textit{hardware} o software dove sono contenuti i protocolli di quel livello. Per offrire servizi allo 
strato superiore, è presente un punto logico chiamato \textit{Service Access Point} ({\textcolor{cyan}{sap}}) al quale può accedere il livello superiore. 
L'unico punto di contatto tra livelli e quello inferiore è la loro interfaccia. Un protocollo è un linguaggio utilizzato da entità dello stesso livello, quindi entità 
di uno stesso strato possono comunicare con le adiacenti tramite protocolli e con superiori tramite {\textcolor{cyan}{sap}}, ed inferiori tramite interfacce:
\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img entità su livelli diversi comunicano con \textcolor{cyan}{sap}, e protocolli dello stesso strato
    \caption{Comunicazione tra Entità della Rete}%  
\end{figure}
I protocolli su uno stesso strato possono comunicare con altre entità dello stesso livello, e possono inviare indicazioni o conferme a richieste di entità utenti del 
servizio del livello superiore. 

Secondo questo modello i pacchetti sono contenuti in altri pacchetti, destinati a livelli inferiori, per cui quando vengono ricevuti da un livello $n-1$, viene letto 
il pacchetto di livello $n-1$ ed estratto il pacchetto di livello $n$ contenuto ed inviato all'entità di livello superiore $n$. 

I dati generati da un protocollo di livello $n$ sono detti $n$-\textcolor{Brown}{pdu}, \textit{Protocol Data Unit}, composti da un \textit{header} indirizzato all'entità di livello $n$ ed una payload, 
contente una $n+1$-\textcolor{Brown}{pdu}, destinata al livello superiore. Per cui all'aumento dei livelli aumenta l'\textit{overhead}:
\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Pila \textcolor{blue}{ISO-OSI} e Rispettive \textcolor{Brown}{pdu}}%  
\end{figure}

\subsection{Livelli}

I diversi livelli di questo modello presentano le seguenti funzioni:
\begin{enumerate}
    \item  Il primo strato della pila \textcolor{blue}{ISO-OSI} rappresenta lo strato fisico, che si interfaccia direttamente con il mezzo trasmissivo della rete e quindi rappresenta il livello di 
    natura fisica della trasmissione. Offre al livello superiore una comunicazione indipendente dal mezzo trasmissivo. Fornisce allo strato di collegamento servizi di 
    trasmissione di bit a tra sistemi adiacenti, consegna in sequenza di bit o notifiche di malfunzionamenti. 
    \item Il secondo livello rappresenta lo strato data-link per risolvere eventuali malfunzionamenti dello strato fisico, rilevando e correggendo errori, tramite algoritmi di correzione, come i bit di parità. 
    Offre allo strato superiore la possibilità di trasmettere \textcolor{Brown}{pdu} a sistemi adiacenti utilizzando due code nelle due direzioni. 
    \item Il terzo livello è lo strato di rete e conosce la topologia completa della rete, per effettuare operazioni di instradamento. Contiene i protocolli come \textcolor{BurntOrange}{IPv4}, 
    progressivamente sostituito da \textcolor{OliveGreen}{IPv6}, e permette il trasferimento di \textcolor{Brown}{pdu} da estremo ad estremo. Inoltre permette la commutazione di circuito o di pacchetto a datagramma e 
    a circuito virtuale. 
    \item Il quarto livello di trasporto, divide il messaggio in pacchetti, prova a colmare fluttuazioni della qualità del servizio dello strato di rete in modo 
    trasparente rispetto agli strati superiori. In caso manchino dei pacchetti prova a recuperarli attraverso algoritmi di correzione, è il primo strato che risiede 
    solamente nei terminali. Offre allo strato superiore la possibilità di instaurare una connessione e gestione della stessa, una trasmissione affidabile, ed il rilascio 
    della connessione. 
    \item Il quinto livello di sessione sincronizza e struttura il dialogo tra due processi.
    \item Il sesto livello di presentazione permette uno scambio di messaggi indipendentemente dalla sintassi della trasmissione. 
    \item Il settimo livello di applicazione offre un mezzo per accedere alla rete tramite un processo, interfacciando l'utente alla rete.  
\end{enumerate}

Per tutti i livelli superiori a quello fisico si possono definire due modalità operative ed associati servizi e protocolli, connessi e non connessi. Nei servizi o 
protocolli connessi, si instaura una connessione o dialogo tra le entità, e termina solamente dopo convenevoli finali. La modalità non connessa non ha bisogno di una 
connessione costante tra le due entità, viene instaurata senza un dialogo da una delle entità senza una terminazione. 

Nella prima modalità l'entità non ha bisogno di ascoltare tutto il traffico per determinare quali \textcolor{Brown}{pdu} sono indirizzati alla stessa, ma necessita di una connessione 
continua anche se vengono trasmessi una piccola quantità di dati. Mentre nella seconda modalità possono essere inviate \textcolor{Brown}{pdu} indipendente dalla connessione e dalla 
distanza temporale tra le due, ma le entità che offrono questo servizio o protocollo devono costantemente analizzare il traffico per individuare le \textcolor{Brown}{pdu} a loro 
indirizzate. 
I protocolli non connessi sono quindi più efficienti, ma mancano di affidabilità, poiché manca una conferma di ricezione dei dati come nei protocolli connessi. quest'ultimi 
sono quindi più affidabili, ma meno efficienti, poiché dopo aver instaurato il dialogo non è possibile terminarlo preventivamente, e ciò può causare uno spreco di risorse. 


In un servizio connesso sono presenti primitive per instaurare una connessione, inviare messaggi e una conferma di ricezione o ricevere messaggi, specificare 
l'indirizzo o nome della connessione ed abbattere la connessione. Mentre per servizi non connessi sono presenti solo primitive per inviare messaggi separatamene. 
Nelle reti \textcolor{violet}{LAN} sono disponibili servizi connessi, solamente sul quarto strato, mentre nelle reti \textcolor{purple}{WAN} è possibile siano offerti anche nel primo strato.  

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Gli Strati \textcolor{blue}{ISO-OSI} agli Estremi e nei Sistemi Intermedi}%  
\end{figure}

I primi tre livelli della pila \textcolor{blue}{ISO-OSI} sono presenti su ogni nodo della rete non solo sui calcolatori, poiché rappresentano i livelli di trasmissione dei pacchetti, 
necessari anche nei nodi intermedi per poter trasmettere i pacchetti. 

Nei protocolli di livello 2, 3 e 4 si utilizzano meccanismi di riscontro o \textit{acknowledgment} e tecniche di controllo a finestra, a riga indice e puntatore in avanti per 
correggere eventuali errori nei pacchetti. 

Gli ultimi tre strati della pila si interfacciano con le applicazioni e lavorano generalmente in parallelo invece che in serie come il resto della pila. 

Una singola connessione di livello $n$ può essere sfruttata da più connessioni di livello $n+1$, interne in modo che gli $n$-\textcolor{Brown}{pdu} contengono entrambe le $n+1$-\textcolor{Brown}{pdu} delle due 
connessioni. Può essere il caso di connessioni tra più processi diversi sulle stesse due macchine, dove una singola connessione tra queste due macchine contenga numerose 
connessioni processo-processo tra le due. 

Inoltre una singola connessione $n+1$ può utilizzare più di una connessione di livello $n$, per parallelizzare la trasmissione e velocizzarla partizionando i dati da 
inviare, oppure per implementare una resistenza ai guasti. La connessione $n+1$ utilizza più canali di comunicazione di livello $n$ non in competizione. 

Una singola connessione di livello $n+1$ nel tempo, può utilizzare più di una connessione di livello inferiore; è possibile che il terminale si sposta durante la 
trasmissione e si aggancia a reti diverse da quella iniziale, senza interrompere la connessione. 
Nello stesso caso, una stessa connessione di livello $n$ continua nel tempo può essere utilizzata da diverse connessioni di livello $n+1$. La connessione originale dell'esempio 
precedente vede uscire il primo terminale e quindi la prima connessione $n+1$ per poi vedere accedere un altro terminale ed un'altra connessione $n+1$. 

\clearpage

\section{Livello 2: Standard IEEE 802}

Lo standard IEEE 802 riguarda i primi due livelli del modello \textcolor{blue}{ISO-OSI}, ovvero il livello fisico, ed il livello data link, per permettere la comunicazione di calcolatori sulla stessa rete locale, personale o metropolitana:
\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Standard IEEE 802}%  
\end{figure}
Le tecnologie definite in base a questo standard quindi hanno come obiettivo la trasmissione 
e la rivelazione o correzione di bit attraverso un mezzo trasmissivo. Si occupano della connessione e quindi comunicazione tra macchine adiacenti, per una qualche definizione di adiacenza. Altri protocolli e standard 
noti sono l'\textcolor{BurntOrange}{IPv4} ed \textcolor{OliveGreen}{IPv6}, protocolli di routing di livello tre, protocolli \textcolor{Bittersweet}{TCP} ed \textcolor{Fuchsia}{UDP} di livello quattro, ed il protocollo \textcolor{NavyBlue}{HTTP} di livello sette, ma si occupa anche da solo delle funzioni dei livelli 5 e 6. 

Questi standard vengono realizzati dall'organizzazione IEEE, \textit{Institute of Electrical and Electronics Engineers}, organizzazione indipendente da stati sovrani. Il progetto IEEE 802 venne definito con 
l'obiettivo di realizzare una serie di standard di livello fisico e data-link per permettere la comunicazione di calcolatori sulla stessa rete locale, \textcolor{violet}{LAN}, personale, PAN, o rete metropolitana, MAN, di grandezza 
intermedia tra le reti \textcolor{violet}{LAN} e \textcolor{purple}{WAN}. Ha avuto successo sopratutto per le reti \textcolor{violet}{LAN} e MAN, ma per le reti personali si utilizza uno standard diverso basato sul bluetooth. 
Questi standard riguardano tecnologie con pacchetti di lunghezza variabile.


Le specifiche tecnologie vengono individuate tramite una notazione puntata, con 802.$x$, dove $x$ rappresenta un numero, ed identifica la tecnologia. I numeri precedenti al punto individuano lo standard dove è 
stata introdotta questa tecnologia. Ma le tecnologie non rimangono invariate nel tempo, per cui si possono assegnare delle lettere dopo il numero per specificare la versione o tipo di quella specifica tecnologia. 

\subsection{802.2: Sottolivello \textcolor{DarkOrchid}{MAC} ed \textcolor{CadetBlue}{LLC}}

Lo standard IEEE 802.2 divide il livello due in due sottolivelli: \textit{Logical Link Control} (\textcolor{CadetBlue}{LLC}) e \textit{Media Access Control}  (\textcolor{DarkOrchid}{MAC}), questi gestiscono due tipologie diverse di pacchetti. Per le diverse tecnologie dello standard, il livello \textcolor{DarkOrchid}{MAC} è diverso, mentre il livello 
\textcolor{CadetBlue}{LLC} è comune a tutti. 
Il sottolivello \textcolor{DarkOrchid}{MAC} è specifico per ogni tipo di \textcolor{violet}{LAN}, si suppone che tutti i calcolatori che devono comunicare siano nella stessa \textcolor{violet}{LAN}. Data questa ipotesi il sottolivello \textcolor{DarkOrchid}{MAC} risolve il problema di determinare 
il destinatario in ricezione, e di verificare la disponibilità della \textcolor{violet}{LAN} in trasmissione, in caso la \textcolor{violet}{LAN} sia a singolo canale condiviso. Quindi bisogna evitare che il canale sia utilizzato da più utenti. 


\subsubsection{Sottolivello \textcolor{DarkOrchid}{MAC}}

Poiché il canale è condiviso, tutti gli utenti possono vedere i pacchetti inviati, sono quindi necessari protocolli di sicurezza e cifratura per impedire che sia possibile a chiunque connesso alla rete di leggere il 
contenuto dei pacchetti. Tecniche che non verranno trattate in questo corso. 
Inoltre si utilizza un canale condiviso in modo che in caso di malfunzionamento fisico, una sola connessione verrebbe compromessa e non l'intera rete. 

Per determinare il destinatario di un pacchetto nella \textcolor{DarkOrchid}{MAC} \textcolor{Brown}{pdu} è presente un campo per definire il tipo di trasmissione:
\begin{itemize}
    \item Punto a Punto: da un calcolatore ad un altro nella \textcolor{violet}{LAN};
    \item Punto a Gruppo: da un calcolatore a diversi altri nella \textcolor{violet}{LAN};
    \item \textit{Broadcast}: a tutti gli utenti connessi alla \textcolor{violet}{LAN}. 
\end{itemize}

Per permettere di identificare univocamente un unico elemento nella rete, gli indirizzi \textcolor{DarkOrchid}{MAC} devono essere univoci nella rete considerata. Dato che è possibile connettersi ad una \textcolor{violet}{LAN} dall'esterno senza conoscere gli 
indirizzi \textcolor{DarkOrchid}{MAC} utilizzati, servirebbe un gestore di rete per assegnarli ad ogni nuova connessione, ma questo è un approccio inefficiente. Si utilizzano quindi indirizzi \textcolor{DarkOrchid}{MAC} univoci a livello mondiale, in questo modo 
nell'intera rete esisteranno solo indirizzi \textcolor{DarkOrchid}{MAC} differenti. Questa condizione vale anche su VPN o LPN, inoltre se su una stessa macchina vengono simulate diverse macchine virtuali, ognuna di esse dovrà avere un 
indirizzo \textcolor{DarkOrchid}{MAC} differente nella \textcolor{violet}{LAN} che utilizzano per comunicare tra di loro. 
Se due macchine avessero lo stesso \textcolor{DarkOrchid}{MAC}, riceverebbero gli stessi pacchetti, e verrebbero riconosciuti da entrambe le macchine come propri. 



La \textcolor{DarkOrchid}{MAC} \textcolor{Brown}{pdu} è composta da diversi campi, che possono variare in base alla tecnologia con l'aggiunta di campi specifici. Ma per ogni tecnologia aderente allo standard IEEE 802 sono presenti sicuramente questi quattro 
campi per la \textcolor{DarkOrchid}{MAC} \textcolor{Brown}{pdu}:
\begin{itemize}
    \item \textcolor{DarkOrchid}{MAC} \textcolor{cyan}{dsap} (\textit{Destination Service Access Point}): indirizzo di destinazione;
    \item \textcolor{DarkOrchid}{MAC} \textcolor{cyan}{ssap} (\textit{Source/Send Service Access Point}): indirizzo di partenza;
    \item Info: \textcolor{CadetBlue}{LLC} \textcolor{Brown}{pdu};
    \item \textcolor{Green}{FCS} (\textit{Frame Check Sequence}): per identificare e correggere eventuali errori.
\end{itemize}

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Struttura \textcolor{DarkOrchid}{MAC} \textcolor{Brown}{pdu}}%  
\end{figure}

Per ottenere l'indirizzo del destinatario, si utilizzano protocolli di acquisizione descritti in seguito. 

Gli indirizzi \textcolor{DarkOrchid}{MAC} sono composti da 6 byte, in base allo standard EUI-48, \textit{Extended Unique Identifier}, per indirizzi a 48 bit, ma esiste anche uno standard a 64 bit non utilizzato. Questi byte vengono rappresentati in forma esadecimale, 
separati da due punti o trattini. I primi tre byte dell'indirizzo \textcolor{DarkOrchid}{MAC} vengono assegnati al costruttore e rappresentano gli OUI \textit{Organization Unique Identifier}, gli ultimi 3 byte vengono scelti dal costruttore. 
Per cui dato un indirizzo \textcolor{DarkOrchid}{MAC}, è sempre possibile determinare il costruttore della macchina a cui appartiene. 

Esistono diversi tipi di indirizzi \textcolor{DarkOrchid}{MAC}, in base al valore di determinati bit:
\begin{itemize}
    \item \textit{Unicast}: indirizzi che individuano le singole schede di rete dei calcolatori; se l'ultimo bit del primo byte ha valore zero;
    \item \textit{Multicast}: indirizzi che identificano gruppi di schede di rete; se l'ultimo bit del primo byte ha valore uno;
    \item \textit{Broadcast}: identificano tutte le schede di rete; se l'indirizzo è \texttt{FF:FF:FF:FF:FF:FF}.  
\end{itemize}

Inoltre è possibile assegnare indirizzi \textcolor{DarkOrchid}{MAC} non unici a livello mondiale, se il penultimo bit del primo byte vale uno. In questo modo è possibile gestire localmente indirizzi \textcolor{DarkOrchid}{MAC} nella stessa \textcolor{violet}{LAN}. 

Per risolvere i conflitti in trasmissione si utilizzano nelle rete \textcolor{Sepia}{WiFi} degli algoritmi distribuiti sulle singole macchine in contemporanea, che collaborano per determinare a chi abilitare gli accessi alla rete. 

\subsubsection{Sottolivello \textcolor{CadetBlue}{LLC}}

Il sottolivello \textcolor{CadetBlue}{LLC} consegna al livello \textcolor{DarkOrchid}{MAC} un pacchetto da spedire, questo pacchetto è uguale per ogni tecnologia aderente allo standard e presenta campi analoghi al sottolivello \textcolor{DarkOrchid}{MAC}. I campi \textcolor{CadetBlue}{LLC}-dsap/ssap individuano 
gli indirizzi \textcolor{CadetBlue}{LLC} del mittente e destinatario, il campo \textit{control} contiene il tipo di \textcolor{Brown}{pdu} per gestire diverse tipologie di pacchetto, e l'ultimo campo contiene la \textcolor{Brown}{pdu} di terzo livello: 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Struttura \textcolor{CadetBlue}{LLC} \textcolor{Brown}{pdu}}%  
\end{figure}

Gli indirizzi \textcolor{CadetBlue}{LLC} non individuano macchine come gli indirizzi \textcolor{DarkOrchid}{MAC}, ma vengono utilizzati per identificare i protocolli di livello 3 a cui sono indirizzati i pacchetti. Consentono la convivenza di diversi protocolli 
di livello 3 sulla stessa macchina e sulla stessa \textcolor{violet}{LAN}, dove sono presenti diverse pile protocollari con obiettivi e versionatura diversa. 

Gli indirizzi \textcolor{CadetBlue}{LLC} vengono attribuiti dall'IEEE solo a protocolli ``ufficialmente'' standard, ma questa è una classificazione che ignora molti dei protocolli più utilizzati a livello globale come \textcolor{Bittersweet}{TPC}/\textcolor{Bittersweet}{IP}, il 
protocollo più utilizzato al mondo. Vengono identificati da un byte in esadecimale, se non sono protocolli standard il loro indirizzo è \verb|AA|, ed il pacchetto subisce una variazione con la snap-\textcolor{Brown}{pdu}, 
\textit{SubNet Access Point}, dopo il campo control di 5 byte per identificare il protocollo. Questo rappresenta un ulteriore livello di \textit{overhead}, già elevato per il modello \textcolor{blue}{ISO-OSI}, per i pacchetti. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{\textcolor{DarkOrchid}{MAC} \textcolor{Brown}{pdu} ed \textcolor{CadetBlue}{LLC} \textcolor{Brown}{pdu}}%  
\end{figure}

\subsection{802.3: Ethernet}
\label{sec:ieee_802.3}


La prima tecnologia ethernet nacque nel 1970 dal consorzio DIX, dalle iniziali delle tre più grandi case produttrici informatiche dell'epoca: Digital, Intel e Xerox. 
In seguito venne revisionato negli anni '80 due volte, nel 1989 lo standard IEEE 802.3 diventa lo standard ISO 8802.3, e negli anni '90 ebbe talmente successo sulle reti \textcolor{violet}{LAN} e \textcolor{purple}{WAN} che divenne essenzialmente lo 
standard di tutte le trasmissioni su filo, completamente retrocompatibile. 
Nel tempo ha usato diversi mezzi trasmissivi, da cavi di rame intrecciati a coppie utp e stp \textit{(Un)Shielded Twisted Pairs}, alla fibra ottica moderna. I cavi di rame venivano avvolti da una isolante dielettrico ed una schermatura esterna (stp), dove erano 
presenti quattro coppie di cavi di rame intrecciati. Questo permetteva connessioni punto-punto bidirezionali e contemporanee. 

Dagli anni '90 in poi la banda massima possibile è aumentata fino ad un massimo di 100-400 Gb/s. 



Il formato del pacchetto ethernet è rimasto sostanzialmente invariato nel tempo, nonostante le sue revisioni, nello standard IEEE 802.3 presenta i seguenti campi:
\begin{itemize}
    \item Preambolo (56 bit): veniva utilizzato per sincronizzare in fase i pacchetti, modalità di trasmissione non più in uso;
    \item \textcolor{Aquamarine}{SFD} \textit{Start Frame Delimiter} (8 bit): indica l'inizio del pacchetto;
    \item Indirizzi \textcolor{DarkOrchid}{MAC} di sorgente e destinazione (96 bit);
    \item Lunghezza del campo dati (16 bit);
    \item Dati: di lunghezza variabile con un massimo di 1500 Byte, contiene una \textcolor{CadetBlue}{LLC} \textcolor{Brown}{pdu};
    \item Pad: eventuale riempimento, da 0 a 46 Byte, la somma con il campo dati deve essere compresa tra 46 e 1500 Byte;
    \item \textcolor{Green}{FCS} \textit{Frame Check Sequence} (32 bit): contiene il valore del codice di ridondanza ciclica (CRC) calcolato. 
\end{itemize}

Non è presente invece un delimitatore finale del pacchetto. I pacchetti hanno una lunghezza minima di 512 bit, mentre una lunghezza massima di 1512 Byte, esclusi il preambolo ed il \textcolor{Aquamarine}{SFD}. Si definisce per la rete ethernet 
l'\textit{Inter-Frame Space} (ITR) o \textit{Inter-Packet Gap} (IPG) come il tempo minimo tra due pacchetti consecutivi. Questo viene definito indipendentemente dalla velocità della rete, come il tempo necessario per 
inviare 96 bit, è necessario per permettere di distinguere due pacchetti inviati consecutivi e determinare si tratti di spazio tra i due. 

Agli albori di questa tecnologia si utilizzavano reti condivise e non punto a punto, quindi bisogna effettuare una connessioni a turni, e per occupare la connessioni su reti di 5 km, si scelse la lunghezza minima di 512 bit. 
Analogamente per la lunghezza massima, se il pacchetto è troppo grande occuperebbe il mezzo trasmissivo per troppo tempo, quindi si è scelto il valore di 1512 Byte. 


Nella trasmissione ethernet il livello \textcolor{DarkOrchid}{MAC} in trasmissione riceve la \textcolor{CadetBlue}{LLC}-\textcolor{Brown}{pdu}, inserendolo nel pacchetto di livello \textcolor{DarkOrchid}{MAC} e convertendolo in bit da passare al livello fisico. In ricezione, converte i bit in un pacchetto 
\textcolor{DarkOrchid}{MAC}, se questo è indirizzato ad un altro oppure contiene errori, calcolando il CRC, viene scartato, altrimenti viene rimossa la parte \textcolor{DarkOrchid}{MAC} ed inviato al livello \textcolor{CadetBlue}{LLC}. 
Scartando pacchetti in questo modo si perde di affidabilità del sistema, ma si guadagna efficienza, poiché si suppone queste informazioni perse vengano recuperate ad un livello superiore (livello di trasporto), 
senza che sia l'ethernet ad inviare una richiesta di ritrasmissione. Ogni terminale che riceve pacchetti deve quindi ricalcolare il CRC, quest'operazione potrebbe rappresentare il collo di bottiglia e deve essere il 
più veloce possibile. Questo livello garantisce una distanza minima tra pacchetti rispettando l'IPG e verifica la lunghezza minima del pacchetto. Se un pacchetto non rispetta la lunghezza minima, viene anch'esso 
scartato. Vengono inoltre generati in trasmissione, e rimossi in ricezione, il preambolo e lo \textcolor{Aquamarine}{SFD} dal pacchetto. 



In passato le reti ethernet erano formate da connessioni sullo stesso filo condiviso tra varie stazioni ed usato a turno, non era punto-punto e bidirezionale. Questo mezzo trasmissivo veniva e viene ancora oggi chiamato dominio di collisione. I pacchetti inviati 
da due o più macchine potevano collidere e si poteva richiedere una ritrasmissione da queste. Questo mezzo condiviso era realizzato da un \textit{repeater} o ripetitore o hub, questo ripete il segnale su tutti i canali connessi e li 
amplifica, a causa della lunghezza delle reti infatti, il segnale poteva perdere di potenza durante la trasmissione. A livello fisico si comporta come un filo, non memorizza infatti i pacchetti che riceve, 
ma li trasmette, non è una macchina \textit{Store \& Forward}. Ripetitori del genere sono ancora diffusi in alcuni contesti. 
Si trova al livello fisico ed ha diverse porta su cui può ricevere dati e trasmetterli su tutte le altre. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Rapporto tra Ripetitore e Standard \textcolor{blue}{ISO-OSI}}%  
\end{figure}

Il mezzo trasmissivo per le connessioni ethernet viene realizzato in cavi di rame o fibra ottica, al massimo di 100 m di lunghezza, progettati senza amplificatori. Si usano coppie separate per trasmissione e 
ricezione per mantenere una connessione bidirezionale. Si usano connettori RJ-45. Reti a fibra ottica invece possono percorrere distanze molto significative rispetto a cavi in rame. 

Ethernet II e ethernet IEEE 802 sono diversi tra di loro, lo standard ethernet II non ha uno sottolivello \textcolor{CadetBlue}{LLC} ed è in generale molto più snello. Nelle reti locali convivono connessioni di entrambi gli standard, e 
sono tendenzialmente molti di più nella vecchia versione di ethernet. Sono necessari quindi meccanismi per mantenere la retrocompatibilità completa dei pacchetti. 
Non essendoci lo strato \textcolor{CadetBlue}{LLC}, il pacchetto di terzo livello viene contenuto direttamente nel pacchetto \textcolor{DarkOrchid}{MAC}, poiché non esiste il livello \textcolor{CadetBlue}{LLC} per questi pacchetti, si utilizza un altro campo type, per specificare a 
quale protocollo di livello superiore inviare il pacchetto. Questo sostituisce il campo lunghezza di IEEE 802.3. Viene riconosciuto se il campo lunghezza ha un valore maggiore di 1500, lunghezza massima del campo 
data, e viene interpretato come un codice identificativo di un protocollo di livello superiore. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Rapporto tra Pacchetti Ethernet II e IEEE 802.3}% + snap
\end{figure}

Poiché ethernet ha vissuto un enorme crescita tecnologia, sono presenti diversi sottolivelli dello standard per classificarle, da versioni 802.3u da 100 Mb/s alle ultime versioni 802.3ba/bg/bm dai 40 ai 100 
Gb/s. Sono inoltre in corso di standardizzazione tecnologie ethernet nell'ordine dei terabit al secondo.  

Generalmente se nel sottolivello dello standard è presente una lettera maiuscola, questo rappresenta un tecnologia estremamente importante. 


Sono presenti inoltre molte versioni differenti per scopi diversi, esiste uno standard specifico per il mercato automobilistico, dove è presente poco spazio interno, e quindi si utilizzano cavi da una singola coppia 
di cavi intrecciati: 802.3bw e 802.3bp (2015/2016) permettono una banda nell'ordine dei gigabit sulla singola coppia. Esiste inoltre uno standard per inviare corrente elettrica su ethernet ed alimentare tramite 
ethernet telefoni \textcolor{Bittersweet}{IP} a bassa tensione: 802.3af e 802.3at (2003/2009). 

\subsection{802.1D: \textit{Bridge}-\textit{Switch}}

La connessione instaurata tramite ethernet è bidirezionale simultanea solamente su due calcolatori, ma su una stessa connessione può inviare i dati un solo 
calcolatore, quindi sono necessarie altre componenti. Un \textit{bridge} è una componente che consente di connettere tra di loro più di un computer 
tramite ethernet, comportandosi come se fosse un calcolatore intermedio ai calcolatori della rete, connesso a ciascuno di questi tramite una connessione 
ethernet. 

Inoltre connettendo tra di loro diversi \textit{bridge} è possibile creare una struttura più articolata, creando una struttura simile ad un albero. La 
parte wired o cablata delle connessioni \textcolor{violet}{LAN} vengono instaurate in questo modo. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img rete con \textit{bridge}, topologia articolata 
    \caption{Rete con \textit{Bridge}}%  
\end{figure}

I \textit{bridge} svolgono una prima funzione di rendere possibili topologie articolate, effettuando un'operazione di \textit{filtering}, per separare tra di loro porzioni di rete che 
non devono dialogare tra di loro in modo diretto


\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{\textit{Filtering} con \textit{Bridge}}%  
\end{figure}

I \textit{bridge} sono delle macchine \textit{Store \& Forward}, ovvero quando ricevono un pacchetto, prima di essere inviato su altre porte, viene 
memorizzato e trasmesso su altre porte, analogamente come se fosse un calcolatore, in caso le altre porte siano impegnate a trasmettere altri 
pacchetti, quindi in caso di traffico. Si può quindi immaginare una coda di pacchetti sulle porte del \textit{bridge} per essere trasmesse. 

Il \textit{bridge} sono delle tecnologie di livello 2, ed utilizzano algoritmi di instradamento per inviarli ad un \textcolor{DarkOrchid}{MAC} \textit{address} specifico, ma questo tipo di 
algoritmo viene effettuato a livello 3. Questo non sorge problemi, poiché quest'operazione di instradamento è interna alla \textcolor{violet}{LAN}, e non coinvolge alcun'altra componente 
della rete. I \textit{bridge} devono essere conformi allo standard IEEE 802.1D. Gli standard comprendenti il carattere ``D'', sono di grande importanza. 
I sistemi connessi a reti \textcolor{violet}{LAN} ignorano i \textit{bridge}, si dicono quindi trasparenti, poiché i calcolatori connessi alla rete non conoscono la loro posizione all'interno della 
rete. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Rapporto tra \textit{Bridge} e Standard IEEE 802}%  
\end{figure}

Un calcolatore per inviare un messaggio ad un altro calcolatore su una rete \textcolor{violet}{LAN}, invia il suo pacchetto ad un \textit{bridge} attraverso il sul \textcolor{DarkOrchid}{MAC} \textit{address}. Il \textit{bridge} quindi 
utilizza in principio un diverso \textcolor{DarkOrchid}{MAC} \textit{address}, per spedire questo pacchetto al computer di destinazione tramite il suo \textcolor{DarkOrchid}{MAC} \textit{address}. Tra questi due \textcolor{DarkOrchid}{MAC} è presenta un 
componente di relay, per trasmettere il pacchetto tra porte diverse del \textit{bridge}. 


Le porte di un \textit{bridge} possono avere lo stesso \textcolor{DarkOrchid}{MAC} o \textcolor{DarkOrchid}{MAC} differenti. Poiché il pacchetto è specifico al \textcolor{DarkOrchid}{MAC} del \textit{bridge}, deve ricostruire il pacchetto scartando i campi 
specifici al \textcolor{DarkOrchid}{MAC} \textit{address} del \textit{bridge}. Inoltre poiché i pacchetti non sono tutti conformi allo standard IEEE 802.3, deve ricostruire anche il campo \textcolor{CadetBlue}{LLC}. I \textcolor{DarkOrchid}{MAC} \textit{address} 
dei computer nella rete sono realizzati in modo da poter essere connessi a ciascun tipo di \textcolor{DarkOrchid}{MAC}. 

\subsubsection{\textit{Learning}}

Si vuole avere un modello di rete \textit{plug \& play}, ovvero indipendente da un intervento umano. 
I \textit{bridge} costruiscono la loro tabella di instradamento per identificare dove sono presenti i diversi indirizzi \textcolor{DarkOrchid}{MAC} autonomamente attraverso un meccanismo di \textit{learning}, 
salvando questa tabella nel \textit{filtering \textit{database}}. Ogni porta del \textit{bridge} rappresenta una linea ethernet diversa, identificando un loro dominio di collisione, a cui 
possono essere connessi diversi calcolatori. 

Si considera una rete dove ogni componente connesso è spento, ed una tabella vuota. Appena si accende un calcolatore ed invia un pacchetto da un dominio di collisione, 
allora il \textit{bridge} capisce a quale porta corrisponde il \textcolor{DarkOrchid}{MAC} \textit{address} del mittente. Ma ancora non conosce dove si trova il destinatario, quindi lo invia su tutte le sue 
porte disponibili, su tutta la rete. Invece se conosce la porta dov'è presente il destinatario lo invia solamente su quella porta. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Processo di \textit{Learning} e \textit{Filtering Database}}%  
\end{figure}

Il learning permette di costruire autonomamente il filtering \textit{database} di un \textit{bridge}, questo meccanismo tuttavia non funziona quando la rete presenta una topologia diversa 
dalla topologia ad albero. Per esempio se è presente un ciclo all'interno della rete, il \textit{bridge} si vede arrivare un pacchetto dallo stesso \textcolor{DarkOrchid}{MAC} \textit{address} su porte diverse. 
Un albero è una topologia contenente solo \textit{Single Points of Failures} (\textcolor{gray}{SPoF}) e quindi fortemente sconsigliata, poiché un singolo malfunzionamento causerebbe la 
perdita di funzionalità dell'intera rete. Per cui data una topologia a grafo, un \textit{bridge} è in grado di calcolare autonomamente un albero 
ricoprente della rete, ricalcolandolo ad ogni cambiamento della topologia. I \textit{bridge} inoltre vengono collegati tra di loro per più di una connessione per evitare altri \textcolor{gray}{SPoF}, ed 
evitare che a un singolo guasto la rete venga tagliata in due. 

Tramite un meccanismo progressivo i \textit{bridge} individuano la loro posizione nella struttura dell'albero ricoprente e sono in grado di staccare alcune porte e rimanere 
collegati sull'intera rete; quando questi \textit{bridge} rilevano un guasto su una di queste connessioni, riattivano una delle porte disattivate per mantenere in funzione la 
rete, ottenendo una significativa resistenza ai gusti. 
Questo tipo di algoritmo di \textit{spanning tree} verrà trattato in corsi più avanzati di reti di calcolatori. 


\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Rete con Albero Ricoprente}%  
\end{figure}

\subsubsection{Prestazioni}

Le prestazioni di un \textit{bridge} influenzano le prestazioni dell'intera rete locale, vengono identificate da una serie di parametri. Il numero massimo di pacchetti al 
secondo processabili dal \textit{bridge} rappresentano un collo di bottiglia, limita il numero massimo dii pacchetti che possono essere presenti sulla rete in ogni singolo momento. Infatti se vengono 
inviati un numero superiore di pacchetti, alcuni verranno scartati. Un altro parametro caratteristico è il tempo medio di latenza, ovvero il tempo in cui il 
\textit{bridge} prende le sue decisioni ed invia il pacchetto alla porta corretta. 
Per cui è preferibile avere \textit{bridge} full speed, ovvero con una velocità pari al massimo teorico. Più corti sono i pacchetti maggiore è il numero di decisioni 
effettuate nell'unità di tempo. Nello standard IEEE 802.3 a 10 Mb/s, un \textit{bridge} si definisce full speed se è in grado di processare 14880 pacchetti al secondo, 
per ogni porta. Questi esperimenti di verifica a parità di frequenza devono essere effettuati utilizzando pacchetti di lunghezza minima, così ad ogni porta è presente 
la massima frequenza di funzionamento del \textit{bridge}. 
Il pacchetto più piccolo che può essere inviato è da 512 bit, per cui il numero massimo di pacchetti al secondo ad una 
velocità di 10 Mb/s è di circa 19500 pacchetti, ma il pacchetto comprende anche il preambolo ed il \textcolor{Aquamarine}{SFD}, per cui vanno aggiunti altri 64 bit ed il 
numero di pacchetti al secondo scende a 17300. 
Tuttavia tra un pacchetto ed il successivo in ethernet è presente l'IPG di 96 bit, in questo modo si ottiene la cifra di 14880 pacchetti al secondo. 
Per ciascuna tipologia di porta del \textit{bridge} si effettua questa analisi e si verifica nel caso peggiore quanti pacchetti è in grado di gestire. 

\subsubsection{Architettura di un \textit{Bridge}-\textit{Switch}}

Il \textit{bridge} è un calcolatore, con una CPU, RAM ed interfacce per le diverse \textcolor{violet}{LAN}, in ROM le funzionalità dello standard IEEE 802.1D, mentre nella memoria principale le tabelle di instradamento i buffer dati, ed eventuali strutture dati ausiliarie. 
Per \textit{bridge} più potenti, le  porte vengono realizzate tramite schede ASIC, per risolvere il problema dell'instradamento localmente. Le porte vengono realizzati tramite 
diversi slot che possono essere inseriti o rimossi in base al tipo di porta necessaria. Inoltre sono necessari massicci impianti di raffreddamento per riuscire a 
mantenere basse la temperature dei data center contenenti \textit{bridge}-\textit{switch}. A differenza di un \textit{server} che può essere rallentano in caso di traffico elevato e quindi diminuire la temperature, le apparecchiature di \textit{bridge} non possono 
spegnersi, e quindi comportano una temperatura costantemente elevata. \textit{Bridge} di fascia alta sono in grado di effettuare bilanci sulle prese di corrente, per distribuire il carico dell'alimentazione. 

Logicamente sono presenti almeno due porte una \textcolor{DarkOrchid}{MAC} \textit{relay entity}, per trasmettere i pacchetti tra le varie porte, ed un'entità di livello superiore, per la gestione 
del \textit{bridge}, degli algoritmi e dei protocolli. Queste entità di alto livello comunicano con altri \textit{bridge} attraverso pacchetti per realizzare lo \textit{spanning tree}. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Architettura Logica \textit{Bridge}-\textit{Switch}}%  
\end{figure}

Le porte del \textit{bridge} possono essere abilitate o disattivate dall'amministratore di rete. Una porta attiva può essere in stato di \textit{forwarding} o di \textit{blocking}, se sono 
bloccate lo \textit{spanning tree} lo ha bloccate. Ogni porta ha un indirizzo \textcolor{DarkOrchid}{MAC} univoco, e sono numerate progressivamente a partire da uno. Convenzionalmente l'indirizzo MAc 
del \textit{bridge} corrisponde all'indirizzo \textcolor{DarkOrchid}{MAC} della porta numero uno. 

La tabella di instradamento contiene \textit{entries} (righe) statiche o dinamiche. Le righe statiche vengono inserite dall'amministratore a causa di esigenze di sicurezza 
importanti, altrimenti la posizione degli indirizzi \textcolor{DarkOrchid}{MAC} vengono mantenute per un tempo finito, configurabile di default di 5 minuti. Infatti è possibile che il calcolatore 
venga spostato spazialmente attraverso la rete, e quindi si colleghi ad una porta differente. 


Lo sviluppo di ethernet ha portato alla creazione di meccanismi di controllo di flusso, soprattutto per gli \textit{switch}. Una richiesta attraverso il \textit{bridge} può essere di 
pochi byte verso un \textit{server}, ma può provocare un trasferimento notevole di dati verso il \textit{client}, quindi attraverso il \textit{bridge} ad una porta ad alta velocità, ma questi 
pacchetti da ritrasmettere verso il cliente passano attraverso una porta di banda minore, quindi la porta più lente può andare facilmente in saturazione. 
Viene introdotto quindi tramite lo standard IEEE 802.3x e 802.3bd un controllo di flusso tramite dei \textit{pause frame} un \textcolor{DarkOrchid}{MAC} control frame di 512 bit, per fermarsi 
prima di riprodurre traffico i pause frame non contengono dati ma contengono informazioni di controllo, e rappresentano una novità, viene quindi implementato 
attraverso un nuovo sottostato di \textcolor{DarkOrchid}{MAC} chiamato \textcolor{DarkOrchid}{MAC} control. Il supporto allo standard 802.3x è opzionale e viene negoziato tra le schede alle due estremità del filo. 

Prima dello standard 802.3x poiché ethernet era una comunicazione a turni, per impedire la saturazione i \textit{bridge} potevano inviare pacchetti senza dati prendendo il 
controllo della connessione. 

\subsection{802.11: \textcolor{Sepia}{WiFi}}

Nelle reti ethernet, si ha una connessione punto a punto bidirezionale e simultanea, attraverso \textit{bridge} che permettono di comunicare tra 
diversi computer senza connetterli direttamente. Per cui gli indirizzi \textcolor{DarkOrchid}{MAC} ethernet sono molto semplice, ma questo non si 
può dire per le reti \textcolor{Sepia}{WiFi}. Una rete locale è un ambiente dove tutti parlano contemporaneamente con tutti, e ciò non può avvenire su di un filo condiviso tra due 
calcolatori. Quindi le connessioni \textcolor{Sepia}{WiFi} presentano un indirizzo \textcolor{DarkOrchid}{MAC} molto più complesso. 

Ethernet è molto versatile, ma su alcuni edifici non è possibile effettuare un cablaggio economico, oppure sono presenti uffici nei quali gli impiegati sono 
presenti occasionalmente. Oppure nel caso di reti offerte pubblicamente, con utenti occasionali. 
Per questi motivi di praticità nei portatili moderni sono presenti schede di rete \textcolor{Sepia}{WiFi} e non ethernet. 

Nonostante questi benefici, il mezzo trasmissivo non è affidabile, e comporta un costante consumo elettrico per connettersi alla rete, inoltre comprende una zona di copertura limitata. Esistono diversi studi sull'uso delle frequenze o micro-frequenze sulla salute. 

Il sistema \textcolor{Sepia}{WiFi} nel venne definito nel comitato IEEE 802, dove forma il working group 802.11 dedicato alle \textcolor{violet}{LAN} senza fili. Il primo standard ad affermarsi è 802.11b. 
Nel 1999 si forma il consorzio \textit{Wireless Ethernet Compatibility Alliance}, successivamente denominato \textcolor{Sepia}{WiFi} \textit{Wireless Fidelity Alliance} per certificare i prodotti 
IEEE 802.11. 

\subsubsection{Architettura}

Una rete \textcolor{Sepia}{WiFi} può presentare architetture di due tipi, ad hoc o strutturate. In una rete ad hoc le stazioni comunicano direttamente l'una con l'altra:

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Rete \textcolor{Sepia}{WiFi} ad Hoc}%  
\end{figure}

Quest'architettura è prevista dallo standard, ma le reti \textcolor{Sepia}{WiFi} non funzionano in questo modo, è stata progettata per permettere di comunicare ai 
dispositivi personali, ma su questo ambiente applicativo ha prevalso il Bluetooth. 

Le reti \textcolor{Sepia}{WiFi} sono invece realizzate con un'architettura strutturata, dove tutte le stazioni (astrazione di calcolatore poiché funziona su tante tipologie di dispositivi) possono accedere 
solamente tramite punti di accesso \textit{Access Point} (\textcolor{PineGreen}{AP}). Questi punti di accesso sono interconnessi mediante fili, quindi non rappresenta una rete completamente senza fili. 
Questi collegamenti vengono realizzati tramite ethernet, rappresentato come un unico domino di collisione, nonostante sia presente una topologia più complessa. 
In queste reti non è presente un master, ma tutti gli \textcolor{PineGreen}{AP} sono allo stesso livello, in modo che non siano presenti \textcolor{gray}{SPoF}. 


\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Rete \textcolor{Sepia}{WiFi} Strutturata}%  
\end{figure}


Quest'architettura permette una semplice scalabilità, infatti è sufficiente connettere altri \textcolor{PineGreen}{AP} alla rete ethernet. 
L'informatica deve essere scalabile, con costi limitati deve poter aumentare le sue infrastrutture.  


Ciascuno di questi \textcolor{PineGreen}{AP} ha un \textcolor{DarkOrchid}{MAC} di tipo IEEE 802.11, e si comporta come un \textit{bridge}, presenta almeno due interfacce, una 802.11 per comunicare con i dispositivi wireless, 
ed un'altra porta 802.3 per comunicare sulla rete ethernet. Ma questi pacchetti possono essere inviati con due \textcolor{DarkOrchid}{MAC} differenti, quindi necessitano di un'entità di relay per poter 
gestire questi i due diversi tipi. Ogni \textcolor{PineGreen}{AP} controlla un \textit{Basic Service Set} (\textcolor{Rhodamine}{BSS}), che estende la rete cablata. Ogni \textcolor{Rhodamine}{BSS} ha un identificatore, \textcolor{Rhodamine}{BSSID}, che può essere il \textcolor{DarkOrchid}{MAC} della scheda \textcolor{PineGreen}{AP} corrispondente, ma è possibile assegnare valori arbitrari. 
La parte cablata si chiama \textit{Distribution System} (\textcolor{RawSienna}{DS}), e rappresenta l'infrastruttura portante della rete. 

Sono presenti delle eccezioni, infatti è possibile costruire dei collegamenti tra \textcolor{PineGreen}{AP} che estendono il \textcolor{RawSienna}{DS} tramite \textcolor{Sepia}{WiFi}. Ma dal punto di vista dell'architettura si comporta 
come un filo, collegando solamente due \textcolor{PineGreen}{AP}. 


Per gestire il sottolivello \textcolor{DarkOrchid}{MAC}, bisogna gestire il problema dell'accesso al mezzo trasmissivo condiviso. Inoltre bisogna avere una spedizione affidabile dei pacchetti 
su un mezzo trasmissivo poco affidabile. 
Livelli fisici differenti utilizzano frequenze e bande diverse. Il sottolivello \textcolor{DarkOrchid}{MAC} viene a sua volta diviso in due sottolivelli, questo viene effettuato per permettere 
di realizzare architetture modulari. 
Un sottolivello \textit{Distributed Coordination Function} (\textcolor{OrangeRed}{DCF}), e \textit{Point Coordination Function} (PCF), questi due livelli sono connessi indipendentemente al sottolivello \textcolor{CadetBlue}{LLC}. 
L'accesso distribuito al mezzo trasmissivo viene realizzato nel \textcolor{OrangeRed}{DCF}, questo è il modello effettivamente utilizzato. Rappresenta il \textcolor{DarkOrchid}{MAC} vero e proprio, e tramite questo 
le macchine tentano di accedere al mezzo trasmissivo, ma non è garantito questo accesso, e può comportare ritardi. 
In alcuni ambienti applicativi si vuole accedere al mezzo trasmissivo con garanzia di un tempo di ritardo massimo che non superi una certa soglia. In queste 
applicazioni si sceglie una stazione di riferimento centrale che in ogni intervallo temporale indica chi può trasmettere con il mezzo trasmissivo. Ambienti \textit{Mission Critical}, 
dove una macchina deve necessariamente effettuare un azione in un certo intervallo di tempo utilizzano quindi il PCF.  

La probabilità che il ritardo sia elevato in una rete \textcolor{Sepia}{WiFi} è molto bassa, per cui questa tecnologia non viene quasi mai utilizzata. Poiché bisognerebbe 
utilizzare un controllore centralizzato che si cerca molto spesso di evitare in una rete. 

\subsubsection{Indirizzamento}

Per qualunque \textcolor{DarkOrchid}{MAC} IEEE 802.2 deve essere presente l'indirizzo del destinatario, del mittente, il campo dati e il \textcolor{Green}{FCS}. 
Invece nello standard 802.11 sono presenti campi come il \textit{Frame Control} che indica il tipo di pacchetto, di controllo o contenente dati, e fornisce anche informazioni 
sul mittente ed il destinatario del \textcolor{RawSienna}{DS}, sulla frammentazione e sulla riservatezza. Contiene un campo per indicare il tempo necessario in cui deve 
essere effettuata la trasmissione. Sono inoltre presenti fino a quattro indirizzi \textcolor{DarkOrchid}{MAC}. Il \textit{Sequence Control} contiene informazioni utili per la frammentazione o il riassemblaggio 
dei pacchetti. Il pacchetto contiene una \textcolor{CadetBlue}{LLC} \textcolor{Brown}{pdu} oppure informazioni di controllo ed un \textcolor{Green}{FCS} di 32 bit. 


Si parla quindi di indirizzamento per spiegare il motivo per cui sono presenti fino a quattro indirizzi \textcolor{DarkOrchid}{MAC} in un unico pacchetto. Ogni scheda di rete 
wireless contiene un suo indirizzo \textcolor{DarkOrchid}{MAC}, e questa raccoglie i pacchetti e verifica che sia diretto alla stessa macchina dal suo indirizzo \textcolor{DarkOrchid}{MAC}. Nel pacchetto di livello \textcolor{DarkOrchid}{MAC} 
sono presenti quattro indirizzi numerati da 1 a 4, più due bit. Questi bit sono ToDS e FromDS, se il primo bit vale 1, questo pacchetto è spedito all'\textcolor{PineGreen}{AP} per essere 
smistato dal \textcolor{RawSienna}{DS}, il secondo vale uno quando il pacchetto è destinato al \textcolor{RawSienna}{DS}. In funzione di questi valori i quattro indirizzi hanno significati diversi. 

\begin{center}
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        ToDS& FromDS& Addr. 1& Addr. 2 &Addr. 3&Addr. 4\\\hline
        0&0&DA&SA&\textcolor{Rhodamine}{BSSID}&\\\hline
        0&1&DA&\textcolor{Rhodamine}{BSSID}&SA&\\\hline
        1&0&\textcolor{Rhodamine}{BSSID}&SA&DA&\\\hline
        1&1&RA&TA&DA&SA\\\hline        
    \end{tabular}
\end{center}
Dove RA, \textit{Recipient \textit{Address}} indica la scheda del ricevente, TA, \textit{Transmitter \textit{Address}}, del trasmittente. DA, \textit{Destination \textit{Address}}, indica il destinatario finale e SA, \textit{Sender \textit{Address}}, indica la sorgente. 

In generale il primo indirizzo è sempre l'indirizzo \textcolor{DarkOrchid}{MAC} della scheda di rete a cui è destinato il pacchetto, ed il secondo indirizzo della scheda che lo trasmette. Il terzo indirizzo contiene l'indirizzo sorgente se viene spedito dal \textcolor{RawSienna}{DS}, ed il destinatario se viene spedito al \textcolor{RawSienna}{DS}. In caso è un pacchetto di comunicazione tra il \textcolor{RawSienna}{DS} entrambi questi bit valgono uno, quindi si utilizza il quarto indirizzo per contenere l'indirizzo sorgente. 

Quando due computer comunicano direttamente, su una rete ad hoc, il primo indirizzo del pacchetto corrisponde all'indirizzo del destinatario ed il seguente all'indirizzo 
del mittente. Il terzo campo di indirizzo corrisponde al \textcolor{Rhodamine}{BSSID}, ma questo si riferisce solamente alle reti strutturate. In questo modello le macchine comunicano tra di 
loro in gruppi chiusi, quindi condividano un identificatore chiamato \textcolor{Rhodamine}{BSSID}. La connessione è quindi lecita solamente se il \textcolor{Rhodamine}{BSSID} è lo stesso. Poiché si tratta di 
una comunicazione diretta, i suoi bit hanno valore nullo. 

In una trasmissione da una stazione ad un \textcolor{PineGreen}{AP}, il primo indirizzo è l'indirizzo dell'access point, il secondo è quello del mittente vero. Il terzo indirizzo è quello 
del pacchetto vero. Questi \textcolor{PineGreen}{AP} sono comunque trasparenti rispetto alle macchine, poiché alla prima connessione il calcolatore memorizza l'indirizzo del \textcolor{Rhodamine}{BSSID} a cui può 
richiedere accesso per inviare e ricevere pacchetti. 

Quando un pacchetto viene inviato dal \textcolor{RawSienna}{DS}, il primo indirizzo è il \textcolor{DarkOrchid}{MAC} del destinatario vero, il secondo è l'indirizzo dell'\textcolor{PineGreen}{AP} che lo invia, ed il terzo è l'indirizzo del 
vero mittente. 

Nell'ultimo caso, il pacchetto è inviato e ricevuto dal \textcolor{RawSienna}{DS}, è il caso di due \textcolor{PineGreen}{AP} che comunicano tra di loro tramite \textcolor{Sepia}{WiFi}. Sono necessari i due indirizzi degli \textcolor{PineGreen}{AP} e gli 
indirizzi del destinatario e del mittente vero. 

\subsubsection{Sottolivello \textcolor{OrangeRed}{DCF} ed \textcolor{Dandelion}{RTS}/\textcolor{Dandelion}{CTS}}

Per realizzare dei turni senza una stazione di coordinamento centralizzata si utilizza il sottolivello \textcolor{OrangeRed}{DCF}. Il \textcolor{OrangeRed}{DCF} ha come requisiti principali evitare interferenze di 
trasmissioni simultanee, consentendo il maggior numero possibile di connessioni e gestendo il canale trasmissivo in modo equo. Non si vuole utilizzare un controllore 
centralizzato, e quindi non si può utilizzare un clock. Le trasmissioni sono quindi asincrone. 
Si utilizza un algoritmo \textit{csma}/\textit{ca}, \textit{Carrier Sense Multiple Access}/\textit{Collision Avoidance}. Questo meccanismo determina se il mezzo trasmissivo è disponibile, in caso 
una stazione ha un pacchetto da spedire \textit{Carrier Sense}. Se il mezzo è occupato aspetta che la stazione sia libera prima di trasmettere. 
\`{E} possibile che due stazioni provino a trasmettere contemporaneamente, in questo caso si verifica una collisione ed i pacchetti diventano intellegibili per 
i destinatari, e dovranno essere ritrasmessi. Per evitare le collisioni si utilizzano degli strumenti come \textit{backoff}, \textit{acknowledgment}, \textit{Request to Send}/\textit{Clear to Send} (\textcolor{Dandelion}{RTS}/\textcolor{Dandelion}{CTS}). 

\textcolor{OrangeRed}{DCF} per effettuare il suo lavoro utilizza gli intervalli tra due pacchetti consecutivi per gestire delle priorità. Questo tempo è l'interpacket gap, che in ethernet 
è lungo 96 bit-time. Ci sono due tipi principali di IFS, \textit{Inter-Frame Space}, di tempo variabile tra i vari pacchetti: DIFS, \textcolor{OrangeRed}{DCF} IFS, in generale quello standard, e 
SIFS, \textit{Short} IFS di lunghezza minore. 
Se un pacchetto consecutivo può essere trasmesso immediatamente, allora si utilizza il SIFS, altrimenti si utilizza il tempo di standard DIFS. 


Per ora si considera il \textcolor{OrangeRed}{DCF} senza il \textcolor{Dandelion}{RTS}/\textcolor{Dandelion}{CTS}, per evitare collisioni.  
Quando una stazione vuole trasmettere, ed il canale è occupato, capisce che è presente traffico nel canale, e si autolimita scegliendo un numero random di \textit{backoff}, 
nell'intervallo $[0,cw]$, ed incrementa il timer solo quando è libero. La trasmissione può essere effettuata solamente quando il timer raggiunge il termine. 

Quando una stazione rileva una collisione, utilizzando vari meccanismi, duplica il $cw$ in modo che l'intervallo di casualità sia duplicato, per rendere più 
improbabili collisioni future. Il valore di $cw$ è limitato superiormente al valore $cw_{\max}$, immutabile. Se è un pacchetto viene inviato con successo, il valore di $cw$ viene posto al 
valore minimo $cw_{\min}$. 
Valori ragionevoli per questo intervallo $[cw_{\min},cw_{\max}]$ sono $[7,31]$ e $[255, 1023]$. 

Per determinare se il canale trasmissivo è libero, si utilizza un'altro meccanismo. In ogni pacchetto viene specificata la sua durata, nel campo \textit{duration}. Poiché 
il mezzo trasmissivo è condiviso, tutte le stazioni connesse ascoltano questo campo e si segnano la durata della trasmissione corrente nel vettore NAV, \textit{Network 
Allocation Vector}. Rappresenta un contatore per sincronizzare le stazioni. Ogni stazione lo decrementa con il passare del tempo, ed ogni stazioni può trasmettere 
solamente se questo campo vale zero. Questo campo deve essere presente come primo campo del pacchetto, per essere letto. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Trasmissione Senza \textcolor{Dandelion}{RTS}/\textcolor{Dandelion}{CTS}}%  
\end{figure}

Ogni pacchetto spedito da una stazione deve essere riscontrato dalla stazione destinataria tramite un \textit{acknowledgment}. Quindi una macchina quando calcola la durata 
della trasmissione, calcola il tempo di trasmissione, nota la banda ed il numero di bit del pacchetto, una durata SIFS più corta di DIFS prima dell'invio 
dell'\textit{acknowledgment}, e la durata di questo piccolo pacchetto. Il SIFS corrisponde all'\textit{interpacket space} che separa un pacchetto dal suo \textit{acknowledgment}. 


La verifica della disponibilità della rete può essere effettuata anche a livello fisico, controllando se nel canale trasmissivo è presente del segnale attivo. Se viene rilevato un segnale attivo, la stazione aspetta di trasmettere, quindi solo quando entrambe le condizioni fisiche e logiche sono verificate. 
Una trasmissione non si interrompe fino alla fine, e termina quando viene ricevuto il pacchetto \textit{ack}. La stazione mittente si calcola quando dovrebbe ricevere l'\textit{ack}, se non viene ricevuto, oppure è intelligibile, allora si è verificata 
una collisione, e deve essere ritrasmesso il pacchetto. 
Quindi tra tutte le stazioni nella rete solo la stazione trasmittente è in grado di accorgersi che si è verificata una collisione. In questo caso duplica il valore di $cw$ ed 
aspetta prima di inviare nuovamente il pacchetto.  

Se una stazione trasmettesse senza interruzioni, allora il mezzo trasmissivo non sarebbe mai libero. Questo potrebbe rappresentare un malfunzionamento oppure un attacco di tipo DOS \textit{Denial Of Service}. 


Se il pacchetto che viene trasmesso è molto lungo, e si effettua una collisione, la stazione mittente se ne può accorgere solamente dopo il periodo di trasmissione di 
questo lungo pacchetto. Si perde molto tempo prima dell'identificazione della collisione. 
Per risolvere questo problema la dimensione massima dei pacchetti \textcolor{Sepia}{WiFi} è di 1500 byte come in ethernet. 
Inoltre è possible che tra le stazioni ci sia visibilità parziale, ovvero può vedere solo una parte della rete, a causa della loro collocazione. 

Per risolvere questi problemi si considera l'algoritmo \textcolor{OrangeRed}{DCF} con \textcolor{Dandelion}{RTS}/\textcolor{Dandelion}{CTS}. 
Quando una stazione vuole trasmettere, invia un \textit{frame} al destinatario, di breve lunghezza, chiedendo l'autorizzazione alla trasmissione. Se il destinatario è disponibile 
emette un breve \textit{frame} di conferma. Alle stazioni vicine è richiesto di non interferire per l'intera durata della trasmissione che sta per avvenire. Questo 
meccanismo di prenotazione del canale tra due stazioni permette di evitare le collisioni. 
Se il canale è libero, la stazione mittente invia un pacchetto \textcolor{Dandelion}{RTS} per richiedere l'autorizzazione, e viene concessa alla stazione con un pacchetto \textcolor{Dandelion}{CTS}. Tutte le altre 
stazioni aspettano la durata di tempo indicata nel campo \textit{duration} dei pacchetti \textcolor{Dandelion}{RTS} e \textcolor{Dandelion}{CTS}, invece che nel pacchetto da trasmettere. 

Le stazioni memorizzano la durata residua nel loro NAV, decrementandolo al passare del tempo. 
Una collisione si verifica quando all'invio del \textcolor{Dandelion}{RTS}, non viene inviato il \textcolor{Dandelion}{CTS}, causato da un invio simultaneo del \textcolor{Dandelion}{RTS}. Analogamente alle condizioni precedenti, dove al pacchetto non viene seguito l'\textit{ack}.

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img diagramma di Gantt
    \caption{Trasmissione Con \textcolor{Dandelion}{RTS}/\textcolor{Dandelion}{CTS}}%  
\end{figure}

Quindi nel MAC 802.11 l'algoritmo di \textit{backoff} impone ad una stazione che rileva una collisione o trova il canale occupato di scegliere casualmente in $[0,cw]$ utilizzato per inizializzare il timer di attesa del \textit{backoff} moltiplicandolo per lo \textit{slot time}. Ad ogni collisione sullo stesso pacchetto viene raddoppiato il $cw$ fino ad un valore massimo di $cw_{\max}$. Quando il canale è libero, ovvero se NAV è nullo, viene decrementato il timer per ogni \textit{slot time} passato. Quando il timer si azzera la stazione può trasmettere e se ha successo il wuo $cw$ viene riassegnato al valore minimo $cw_{\min}$. 
L'algoritmo di backoff rappresenta un algoritmo distribuito su molte macchine. 

Su ogni stazione \textcolor{Sepia}{WiFi} è presente un parametro che indica quale pacchetti da utilizzare. Viene utilizzato \textcolor{Dandelion}{RTS}/\textcolor{Dandelion}{CTS} per pacchetti di lunghezza maggiore a questo parametro $s$. Molto spesso questo valore corrisponde alla dimensione massima di un pacchetto 1500 Byte. 

\subsubsection{\textit{Handshaking}}

In queste reti senza fili l'insieme delle stazioni appartenenti ad uno stesso \textcolor{Rhodamine}{BSS} cambia continuamente. Per poter accedere ad un \textcolor{Rhodamine}{BSS} si possono utilizzare 
protocolli di \textit{handshake} in due modalità. 

Si utilizza un protocollo di \textit{handshake} per scambiare informazioni tra l'\textcolor{PineGreen}{AP} ed il \textcolor{Rhodamine}{BSS}. Ogni stazione \textcolor{PineGreen}{AP} presente il proprio indirizzo \textcolor{DarkOrchid}{MAC}, potrebbe inviare un messaggio 
al \textcolor{Rhodamine}{BSS} per indicare la sua presenza alla rete, tramite un pacchetto \textit{broadcast} chiamato \textit{beacon frame}, ricevuto da tutte le stazioni connesse
Altrimenti le stazioni potrebbero inviare pacchetti sonda o \textit{probe}, di tipo \textit{probe \textit{request}}, per esplorare la rete, ed attende un pacchetto di \textit{probe response} di risposta dall'\textcolor{PineGreen}{AP}. Queste rappresentano le due modalità per cui una stazione può accedere ad un \textcolor{Rhodamine}{BSS}. 

Un amministratore può definire varie reti logiche sulla stessa rete fisica, ciascuna identificata a un suo SSID, \textit{Service Set ID}. Un \textcolor{PineGreen}{AP} con un \textcolor{Rhodamine}{BSSID} può rendersi disponibile per trasportare il traffico di uno o più SSID. 
Solo chi ha gli opportuni permessi può accedere ad una specifica rete logica definita da uno specifico SSID. Si definisce ESS, \textit{Extended Service Set} l'insieme delle stazioni appartenenti 
ai \textcolor{Rhodamine}{BSS} di una rete e con lo stesso SSID. 
Queste stazioni nello stesso ESS possono muoversi cambiando \textcolor{Rhodamine}{BSS}, mantenendo invariato il loro ESS. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Rete \textcolor{Sepia}{WiFi} con \textcolor{Rhodamine}{BSS} ed ESS}%  
\end{figure}

\subsubsection{Frammentazione}

Il livello \textcolor{DarkOrchid}{MAC} può decidere se frammentare un pacchetto ed in caso si occupa anche del riassemblaggio. In queste reti è consigliabile diminuire l'\textit{overhead} di un pacchetto e ridurre la 
probabilità di collisione, diminuendo la dimensione dei singoli pacchetti. 
Ogni frammento del \textcolor{DarkOrchid}{MAC} \textit{Service Data Unit} viene frammentato e ciascuno di questi frammenti viene trattato come un pacchetto e viene riscontrato singolarmente. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{\textcolor{DarkOrchid}{MAC} \textit{Service Data Unit} Frammentata}%  
\end{figure}

La dimensione dei frammenti può essere modificata dall'utente per guadagnare un vantaggio in trasmissione sulle altre stazioni. 
In ricezione il livello \textcolor{DarkOrchid}{MAC} ricompone questi frammenti in modo che gli strati superiori non si accorgono della frammentazione, né gli altri \textcolor{DarkOrchid}{MAC} che non 
sono coinvolti nella trasmissione. 

In questo momento storico i riscontri di \textcolor{CadetBlue}{LLC} non vengono utilizzati, quindi anche se nello standard è possibile che l'invio e ricezione di pacchetti \textit{ack} sia effettuata a 
livello \textcolor{CadetBlue}{LLC}, nella realtà non viene realizzato. 

Per inviare pacchetti di tipo \textit{broadcast}, dove ToDS sia pari a zero, non si utilizzano \textit{ack} e \textcolor{Dandelion}{RTS}/\textcolor{Dandelion}{CTS}, le eventuali collisioni non vengono quindi rilevate. Quando 
ToDS è pari ad uno, si utilizzano pacchetti di \textit{ack}, ed \textcolor{Dandelion}{RTS}/\textcolor{Dandelion}{CTS} per i pacchetti diretti verso gli \textcolor{PineGreen}{AP}. Si può configurare l'\textcolor{PineGreen}{AP} in modo che ogni pacchetto 
\textit{broadcast} ricevuto venga inviato o meno a tutto il \textcolor{Rhodamine}{BSS}. 


\clearpage

\section{Livello 3: Il Livello di Rete}

Il livello di rete sceglie un percorso per i pacchetti, conoscendo la topologia della rete, attraverso passaggi intermedi chiamati salti o \textit{hop} tra varie stazioni. 

Se il destinatario è nella stessa \textcolor{violet}{LAN} del mittente, allora lo raggiunge direttamente, altrimenti deve percorrere diverse reti geografiche effettuando questi salti. 
Fino ad ora ci si è occupati di ogni salto separatamente nella rete locale o nella rete geografica. Queste due reti presentano due topologie molto diverse, la rete locale presenta una topologia molto complessa con diverse stazioni intermedie, mentre le reti geografiche sono composte da una trasmissione punto a punto su un unico filo.  
Per connettere tra di loro la \textcolor{violet}{LAN} e la \textcolor{purple}{WAN} si utilizzano reti di raccolta o di accesso. 

\subsection{Reti di Raccolta e Reti di Accesso}

Nella \textcolor{violet}{LAN} la trasmissione tra due stazioni, per quanto sia complessa la topologia della rete, è sempre diretta. Nelle reti geografiche (\textcolor{purple}{WAN}), la trasmissione tra due 
stazioni a livello due avviene su un canale punto a punto. Viene realizzato solamente tramite un filo, non sono necessarie altre componenti della rete. Tipicamente 
questo filo è di tipo ethernet, anche se lo standard è stato sviluppato principalmente per reti locali. 

I collegamenti tra questi due tipi di rete vengono realizzati dall'\textcolor{teal}{ISP} di cui si usufruiscono i servizi. Questa zona intermedia viene realizzata tramite reti di 
raccolta o di accesso. La rete di raccolta è la rete nella quale si raccoglie il traffico, mettendolo assieme, proveniente da tutte le stazioni coperte dal servizio 
dell'\textcolor{teal}{ISP}. Le reti di accesso permettono, una volta raccolto il traffico, di accedere alla rete geografica vera e propria, composta da lunghi collegamenti punto-punto. 


Per molti anni in quasi tutti i paesi del mondo, la rete di raccolta è stata la rete telefonica composta da un doppino telefonico, due fili di rame. Questa struttura molto 
pervasiva è stata il supporto delle comunicazioni di rete per molti anni. 
In seguito venne effettuata una progressiva sostituzione tra rame e fibra ottica, secondo una terminologia FTTx, \textit{Fiber To The x}, che distingue le reti di raccolta in base alla vicinanza della rete locale alla fibra ottica. La linea di tendenza punta a FTTH, \textit{Fiber To The Home}, dove la fibra ottica arriva direttamente alla stazione dell'utente. Un altro metodo di 
raccolta simile è FTTB, \textit{Fiber To The Building}, che utilizza le esistenti strutture telefoniche per trasmettere i dati all'interno dell'edificio. 

FTTN, \textit{Fiber To The Node}, e FTTC, \textit{Fiber To The Center}, sono difficili da distinguere, questi rappresentano gli accessi xDSL o aDSL, \textit{x/aDigital Subscriber Line}, quelli normalmente venduti, il carattere prefisso di DSL descrive la trasmissione 
in termini di bilanciamento e traffico disponibile. In generale il cavo in fibra ottica raggiunge una stazione centrale che utilizza le preesistenti reti telefoniche per raggiungere gli utenti ed i loro edifici. FTTN ed FTTC si distinguono in base alla distanza tra queste stazioni centrali e le stazioni degli utenti, in generale se la distanza è maggiore di 300 metri si parla di FTTN, altrimenti FTTC. 

Tipicamente gli accessi FTTH e FTTB sono a 1 Gb/s, recentemente si stanno vendendo accessi a velocità superiore. 
Queste strutture utilizzano la tecnologia GPON, \textit{Gigabit-capable Passive Optical Network}, il dispositivo vero e proprio di cui fanno uso è l'OLT, \textit{Optical Line Termination}, 
essenzialmente è uno \textit{switch} che gestisce fibre ottiche. Permette di collegare fino a 64 clienti sullo stesso OLT. 
Al livello del cliente è presente un dispositivo \textit{\textit{router}} su cui si può connettere per accedere alla rete, questi sono collegati a vari livelli di \textit{splitting} ottico, per connettere 
tutti i \textit{\textit{router}} dei clienti, connessi tutti su una porta di uno stesso \textit{switch} OLT. Questi dispositivi di \textit{splitting} ottico non necessitano di alimentazione, ma uniscono tra di loro 
il traffico proveniente da più clienti. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{OLT e \textit{Splitting} Ottico}%  
\end{figure}

La banda di questi OLT arriva fino a 1 Gb/s, ma se più clienti vengono connessi alla stessa porta allora la banda effettiva per clienti diminuisce all'aumentare dei 
clienti, fino a 64 per porta. Questa è la rete con gli \textcolor{teal}{ISP} attualmente raccolgono il traffico. 

Per essere collegati alla \textcolor{purple}{WAN}, si utilizza la rete di accesso, realizzata tramite \textit{switch} OLT tutti collegati tra di loro, con un estensione geografica significativa. 
Ma è consigliabile non estendere troppo questa struttura, generalmente indicata come MAN. 
La maggior parte degli \textcolor{teal}{ISP} realizza la propria rete di accesso tramite un anello che connette le varie reti di raccolta e ciò che lo collega alla spina dorsale, la \textcolor{purple}{WAN}, è un nodo di aggregazione. 
Vengono realizzati in cicli per mantenere una certa resistenza ai guasti, e si utilizzano alberi ricoprenti di anello e \textit{loop-avoidance}, con tecnologie analoghe alle 
reti locali, per mantenere attivi solo i collegamenti strettamente necessari. 
Se si rompe un singolo \textit{switch}, solo i clienti attestati a quello \textit{switch} subiranno un disservizio. Generalmente vengono utilizzati più \textit{aggregation node}, per mantenere 
un'importante resistenza ai guasti. Questo meccanismo di duplicare componenti può essere attuato a vari livelli per mantenere alta la resistenza dell'\textcolor{teal}{ISP}. 

Molto spesso per aumentare la robustezza si utilizzano più anelli con doppi collegamenti, anche in fibra, che effettuano percorsi diversi. 
Si utilizza un anello poiché è la struttura contenente cicli più semplice possibile. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Rete di Accesso}%  
\end{figure}

\subsection{Indirizzamento ed Instradamento}

Il livello di rete fornisce servivi al livello di trasporto, che non è interessato della topologia delle varie reti attraversate per raggiungere una destinazione. Inoltre 
non conosce le tecnologie attraversate al livello due. Può offrire servizi connessi e non. Il protocollo di rete più diffuso \textcolor{BurntOrange}{IPv4} utilizza servizi 
non connessi, utilizzando instradamento a datagramma, mentre un livello di rete connesso utilizza la commutazione a circuito virtuale. Questa distinzione tuttavia non è 
strettamente mantenuta. 

Il livello di trasporto deve conoscere degli indirizzi distribuiti in modo consistente su tutta la rete, in modo da poterle identificare univocamente tra rete locale 
e geografica. Una primitiva di servizio non connesso offerta al livello di trasporto indica l'indirizzo livello tre, univoco, del destinatario ed il suo \textit{payload}, questo sarà ricevuto 
dal livello quattro corrispondente. Il livello tre si occupa dell'effettiva trasmissione attraverso la rete. 

Dal punto di vista del livello tre i sistemi possono essere \textit{End System}, \textcolor{Periwinkle}{es}, o \textit{Intermediate System}, \textcolor{Emerald}{is}. Ad ogni sistema viene associato un indirizzo numerico per 
poterlo identificare, spesso viene associato anche un nome, la cui corrispondenza all'indirizzo viene gestita da \textit{server} appositi presenti sulla rete. 

Spesso queste apparecchiature intermedia si chiamano \textit{router} o \textit{gateway}, contengono almeno i primi tre strati della pila \textcolor{blue}{ISO-OSI}, talvolta per motivi di gestione devono 
contenere anche livelli superiori. Alcuni casi di instradamento avvengono anche a livello due, anche se principalmente a livello tre. 


\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img connessione due es, da un is (router), differenza tra bridge (1-2) e repeater (1)
    \caption{\textit{Router}, \textit{Bridge} e \textit{Repeater} e Modello \textcolor{blue}{ISO-OSI}}%  
\end{figure}


L'indirizzo di livello due identifica un destinatario solamente all'interno di una \textcolor{violet}{LAN}, mentre l'indirizzo di livello tre deve poter identificare il destinatario 
all'interno del'intera rete. Un sistema necessita di tanti indirizzi \textcolor{DarkOrchid}{MAC} quante sono le schede di rete al suo interno, ma una singola macchina può essere associata 
ad un singolo indirizzo di livello tre, oppure, per alcuni protocolli come \textcolor{BurntOrange}{IPv4} e \textcolor{OliveGreen}{IPv6}, ad indirizzi di livello tre differenti.  

Esistono protocolli appositi per gestire e stabilire la corrispondenza tra gli indirizzi di livello due e livello tre. Ma gli indirizzi di livello due, i \textcolor{DarkOrchid}{MAC} \textit{address}, 
sono univoci a livello globale, quindi si potrebbe già utilizzare questi come indirizzi di livello tre. Il problema degli indirizzi \textcolor{DarkOrchid}{MAC} è che sono distribuiti casualmente, ma sarebbe utile 
ai fini di individuare le stazioni se gli indirizzi associati a macchine vicine avessero caratteristiche simili. Poiché gli indirizzi \textcolor{DarkOrchid}{MAC} individuano univocamente 
la scheda di rete, mentre gli indirizzi di livello tre possono cambiare, utilizzare solo i \textcolor{DarkOrchid}{MAC} comporterebbe problemi di \textit{privacy}. 

In linea di principio si possono individuare tre tipi di instradamento principali:
\begin{itemize}
    \item \textit{Routing by Network Address}: nel pacchetto c'è l'indirizzo del sistema destinatario, potrebbe non essere l'indirizzo dell'\textcolor{Periwinkle}{es}, ma di una sua interfaccia. Si applica la commutazione a datagramma su questo indirizzo;
    \item \textit{Label Swapping}: nel pacchetto non c'è l'indirizzo, ma un'etichetta che individua un cammino virtuale, con commutazione a circuito virtuale basata su queste etichette;
    \item \textit{Source Routing}: nel pacchetto è indicata la lista ordinata di tutti gli \textcolor{Emerald}{is} da attraversare per raggiungere la destinazione. 
\end{itemize}

\subsubsection{\textit{Routing by Network Address}}

Quando il pacchetto raggiunge un \textcolor{Emerald}{is}, con varie linee di inoltro, questo guarda la sua tabella di instradamento locale e cerca come chiave l'indirizzo del 
destinatario e restituisce la linea dove deve essere inoltrato il pacchetto. La commutazione è a datagramma poiché questa tabella può variare nel tempo. Questo 
rappresenta il modo più semplice di instradamento, operato dagli \textit{switch}, dove la tabella di instradamento viene chiamata \textit{filtering \textit{database}}. 

Se l'indirizzo non fosse presente nella sua tabella di instradamento, allora il pacchetto verrebbe buttato, a differenza dei \textit{bridge}, poiché su reti grandi l'inoltro di 
tutti i pacchetti sconosciuti su tutte le linee comporterebbero un aumento considerevole del traffico. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Instradamento \textit{Routing by Network Address}}%  
\end{figure}

Sono necessari quindi dei protocolli per poter definire gli indirizzi e conoscere la topologia della rete, essendo dinamica. Questi meccanismi permettono di 
compilare automaticamente le tabelle di instradamento dell'intera rete. Ma è possibile che siano compilate manualmente, anche se non è realistico. Questo processo 
di instradamento è indipendente da chi ha compilato la tabella. 

\subsubsection{\textit{Label Swapping}}

Se due stazioni vogliono comunicare, in una rete a circuito virtuale, viene stabilito il percorso che deve attraversare il pacchetto. Le apparecchiature intermedie 
vengono quindi informate sul percorso che deve essere effettuato. Questo percorso viene identificato da un'etichetta in modo che all'arrivo del pacchetto presso un \textcolor{Emerald}{is}, 
si utilizza una tabella dove sono presenti le etichette ed i possibili percorsi, e quindi viene inviato su una certa linea. Questa tabella è locale e molto piccola, e 
determina la linea di ritrasmissione del pacchetto. 

Deve essere stabilito il percorso tra le stazioni, analogamente alla tabella di instradamento precedente. La differenza tra queste due tabelle 
è nelle loro dimensioni, infatti è necessaria una tabella che contenga tutti i destinatari per il meccanismo precedente, mentre una tabella 
delle etichette deve contenere solamente i possibili percorsi. Il numero di righe non è funzione del numero di stazioni globalmente presenti nella rete, ma dal numero 
di circuiti virtuali che la attraversano in ogni dato istante. \`{E} irragionevole che in una rete tutte le stazioni trasmettano a tutte le altre stazioni. 

Per evitare di dover generare etichette uniche in tutta la rete, e quindi verificarne la disponibilità, ad ogni tratto del percorso viene assegnata un'etichetta 
diversa localmente. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Instradamento \textit{Label Swapping}}%  
\end{figure}

In questo modo il numero di etichette disponibili non è un limite superiore al numero dei circuiti virtuali attivabili. Queste etichette sono contenute in un campo 
nell'intestazione del pacchetto. 

\subsubsection{\textit{Source Routing}}

Nel pacchetto viene specificata la lista delle stazioni da attraversare per raggiungere la destinazione. L'\textcolor{Emerald}{is} deve solo leggere questa lista e determinare 
la stazione successiva al quale inoltrare il pacchetto. 

Rappresenta il meccanismo di instradamento più veloce per le stazioni intermedie, ma il percorso deve essere definito a priori e non può essere modificato. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Instradamento \textit{Source Routing}}%  
\end{figure}

\subsection{\textit{Router}}

L'architettura di un \textit{router} è composta da un algoritmo per calcolare la tabella di instradamento, la tabella stessa ed il processo di inoltro dei pacchetti. Sono inoltre presenti almeno due interfacce su cui esegue l'operazione di inoltro. In questo 
corso non ci si occupa dell'algoritmo di creazione automatica della tabella di instradamento. 

La tabella di instradamento ed il processo di ritrasmissione di un pacchetto costituiscono il \textit{data plane}, mentre l'algoritmo di costruzione 
della tabella di instradamento costituisce il \textit{control plane}. Questa rappresenta l'architettura logica di un \textit{router}. 

In un \textit{router} multi-protocollo sono presenti diversi di queste pile di \textit{data} e \textit{control plane} per ogni protocollo, mantenendo le stesse interfacce. 
Un \textit{router} può partecipare contemporaneamente a diverse tecnologie, senza che queste diverse tecnologie e protocolli si conoscano a vicenda sulla stessa macchina. Se ad un \textit{router} 
arriva un pacchetto destinato ad un protocollo che non può gestire, viene scartato, per mantenere le prestazioni. 

\subsection{L'\textit{Internet Protocol Suite} \textcolor{Bittersweet}{TCP}/\textcolor{Bittersweet}{IP}}

Il protocollo di rete \textcolor{BurntOrange}{IPv4}, \textit{Internet Protocol version 4}, appartenente alla \textit{suite} \textcolor{Bittersweet}{TPC}/\textcolor{Bittersweet}{IP} o \textit{Internet Protocol Suite}, è il principale protocollo di rete 
di livello 3. L'\textit{Internet Protocol Suite} è la pila protocollare utilizzata dall'\textit{internet}, implementata nella quasi totalità dei computer. Questi protocolli 
sono descritti nei documenti RFC, \textit{Requests For Comments}. 

Alla fine degli anni '70 nasce l'\textit{Internet Protocol Suite} con \textit{Transmission Control Protocol} o \textcolor{Bittersweet}{TCP}, ed il protocollo \textit{internet} \textcolor{BurntOrange}{IPv4} con una prima versione di \textit{internet} 
chiamata \textit{arpanet}. Da allora è in costante crescita. Già dai primi anni della sua storia \textit{arpanet} permetteva connessioni tra le due coste oceaniche degli Stati 
Uniti. 
Tra  protocolli di \textcolor{Bittersweet}{TCP}/\textcolor{Bittersweet}{IP} abbiamo \textcolor{BurntOrange}{IPv4}, \textcolor{OliveGreen}{IPv6}, \textcolor{Maroon}{ICMP} ed \textcolor{Red}{ARP}, protocolli di supporto, e protocolli di \textit{routing}, di \textit{control plane} per costruire le tabelle di instradamento 
automaticamente, etc.

Si possono realizzare diverse architetture utilizzando protocolli diversi dell'\textit{Internet Protocol Suite} ad ogni livello. 

Quando nasce la \textcolor{Bittersweet}{TCP}/\textcolor{Bittersweet}{IP}, nasce secondo i principi progettuali della semplificazione estrema del \textit{data plane}, in modo che l'inoltro dei pacchetti sia 
effettuato nel modo più semplice possibile. Tutte le funzioni complesse vengono spostate sugli \textcolor{Periwinkle}{es}. Il \textit{routing} è effettuato dall'indirizzo di rete e viene realizzato 
tramite commutatone a datagramma. Il servizio offerto al livello 4 è non connesso. Il servizio è di tipo \textit{best effort}, ovvero un pacchetto può essere corrotto, 
perduto o consegnato in ordine errato, ma non è il livello tre che si occupa della sua ritrasmissione. 

Questi protocolli vennero progettati con il principio della vita stretta, o \textit{narrow waist}, dove i pacchetti a livello 3 sono tutti realizzati con \textcolor{BurntOrange}{IPv4} in modo molto snello, per permettere un'enorme 
interoperabilità tra molti apparati, poiché è il protocollo parlato da tutti. 

\subsubsection{Il Protocollo \textcolor{BurntOrange}{IPv4}}

\textcolor{BurntOrange}{IPv4} è attualmente, insieme ad \textcolor{OliveGreen}{IPv6}, il protocollo principale di livello tre, descritto nell'RFC 791. I pacchetti di questo livello si chiamano \textit{datagram}, datagrammi. 
Provvede a funzioni di instradamento ed indirizzamento, il motivo per cui nasce il livello tre, ma svolge anche la funzione di frammentazione, riassemblaggio e rilevazione degli errori. 
Per i pacchetti la frammentazione è compito del livello quattro, ma già nelle reti \textcolor{Sepia}{WiFi} i pacchetti vengono frammentati, anche se nessuno all'esterno della rete 
\textcolor{Sepia}{WiFi} può rilevare la frammentazione. La frammentazione offerta dal livello quattro compie una riframmentazione, per i pacchetti già frammentati al livello tre 
poiché troppo grandi. Al contrario di una rete \textcolor{Sepia}{WiFi}, nella rete di livello tre i frammenti vengono rilevati. 

I pacchetti di livello tre devono essere contenuti all'interno di un pacchetto di livello due, di campo dati di dimensione 1500 byte. Per cui \textit{datagram} più grandi 
di questa dimensione devono essere frammentati. 
Questo rappresenta un vincolo sulla dimensione del \textit{datagram}, questi pacchetti vengono frammentati solo se strettamente necessario. Provvedere al \textit{routing} deve essere semplice, quindi 
all'arrivo dei frammenti di un \textit{datagram}, il livello tre di un \textit{router} non può riassemblarli, e quindi inoltra i pacchetti allo stesso modo, siano frammentati o meno. 

I pacchetti di livello tre di tipo \textcolor{BurntOrange}{IPv4} sono divisi in due parti, il \textit{datagram \textit{header}} ed il campo dati. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Struttura \textcolor{BurntOrange}{IPv4} \textcolor{Brown}{pdu}}%  
\end{figure}

Questo formato è il linguaggio di quasi tutti gli \textcolor{Periwinkle}{es} ed \textcolor{Emerald}{is} del mondo. Non tutti poiché insieme ad \textcolor{BurntOrange}{IPv4} si sta affermando il protocollo \textcolor{OliveGreen}{IPv6}. 

In generale quando vengono realizzati protocolli vengono inseriti bit o gruppi di bit non utilizzati, per permettere ad evoluzioni future di cogliere circostanze non ancora 
rappresentate dal protocollo. 


La convenzione per rappresentare i pacchetti in RFC è di rappresentare i pacchetti striscia per striscia, di lunghezza di 32 bit, chiamate \textit{long word}. 
I campi versione e ihl, \textit{Internet Header Length} sono entrambi di 4 bit. Il primo campo che si trova è la versione del protocollo che ha generato il pacchetto, è possibile che venga utilizzato da versioni successive, ma questo non è possibile 
per i pacchetti \textcolor{OliveGreen}{IPv6}. Questo campo dovrebbe permettere la migrazione tra due versioni del protocollo chiara, lenta e controllata. Dato un 
protocollo che evolve nel tempo deve essere effettuata un'operazione di \textit{parsing}, strutturando il pacchetto in campi, questo \textit{parser} è diverso per ogni versione. 
Quest'idea 
di utilizzare un campo versione viene utilizzata anche per altri pacchetti di rete. Il campo ihl contiene la lunghezza dell'\textit{header} espressa in \textit{long word}, al minimo pari a 5. 
Per cui dei 1500 byte massimi del pacchetto, 20, al minimo, vengono utilizzati dall'\textit{header}, i restanti 1480 sono disponibili a protocolli di livello superiore. 

Il campo \textit{type of service} specifica la priorità del datagramma rispetto ad altri, ed è diviso in due parti DSCP, \textit{Differentiated Services Code Point}, e 
ECN, \textit{Explicit Congestion Notification}, utilizzati per definire la priorità del pacchetto. 
Quando i pacchetti arrivano in una macchina sono tutti uguali, ma per differenziarli tra di loro si utilizza questo campo per indicare la priorità del pacchetto in 
modo che gli apparati intermedi siano in grado di effettuare le adeguate operazioni. Questi campi priorità vengono specificati da chi ha realizzato quel pacchetto di livello 3, 
ma dipende dal provider. Non tutti i provider sfruttano questa possibilità, se la sfruttano non permettono all'utente di indicarla.
I provider che utilizzano questo strumento possono realizzare offerte commerciali utilizzando questo approccio, assegnando livelli di priorità diversi. Per l'utenza 
domestica questo tipo di offerta non è convenzionale, ma tipicamente è molto comune per aziende. 
La possibilità di rispettare la priorità può essere garantita solamente dagli apparati di loro appartenenza, i \textit{router}, ma questo non è garantito per tutto il 
percorso del pacchetto attraverso la rete. Quando questo pacchetto con priorità arriva in un'area geografica gestita da un altro \textcolor{teal}{ISP}, questo non ha obbligazioni 
commerciali rispetto all'utente, e quindi questi pacchetti vengono gestiti indipendentemente dalla loro priorità. 
Quindi queste offerte sono valide solamente per pacchetti che rimangono all'interno della zona di interesse del \textcolor{teal}{ISP}. 

I campi \textit{ident}, \textit{flag} e \textit{fragment offset} vengono utilizzati frammentare il pacchetto. 
Il livello quattro per realizzare pacchetti di una certa dimensione, richiede al livello tre che a sua volta richiede al livello due il valore massimo di \textcolor{RoyalPurple}{MTU}, \textit{Maximum Transmission Unit}, la dimensione massima di un pacchetto. Quindi il livello di trasporto realizza pacchetti in base alla tecnologia immediatamente 
sottostante. Ogni livello due attraversato da uno stesso pacchetto potrebbe avere diversi valori di \textcolor{RoyalPurple}{MTU}, quindi il pacchetto di livello tre potrebbe essere troppo 
grande ed è possibile sia necessario frammentarlo. Questi frammenti attraversano gli \textcolor{Emerald}{is}, senza essere rilevati come tali, e verranno riassemblati solamente all'arrivo all'\textcolor{Periwinkle}{es}. 
\textcolor{OliveGreen}{IPv6} effettua una scelta radialmente diversa per ilt trattamento dei frammenti, ed alcune di queste scelte migliori vengono implementate anche da \textcolor{BurntOrange}{IPv4}. 

In generale la frammentazione consiste nel suddividere uno stesso pacchetto in più pacchetti di dimensione minore, per essere successivamente ricostituito sulla macchina destinazione. 
Occorrono dei campi nel pacchetto per riconoscere i pacchetto come frammento, riconoscere frammenti generati dallo tesso pacchetto e deve essere possibile determinare 
l'ordine dei frammenti per poterli riassemblare. 
In caso il frammento di livello due deve essere nuovamente frammentato si specifica l'\textit{offset} rispetto al pacchetto originale per ogni nuovo frammento, dato l'\textit{offset} del pacchetto originale. Rappresenta la posizione del primo byte del frammento nel pacchetto originale. Questo valore è univoco per ogni frammento, indipendentemente dal numero di riframmentazioni. 
Il campo \textit{ident}, di 16 bit, identifica un datagramma e serve all'\textcolor{Periwinkle}{es} per determinare il pacchetto di appartenenza del frammento. Se il pacchetto non è frammentato questo rappresenta bit sprecati.  
Il campo \textit{offset} di 13 bit può specificare solo un \textit{offset} multiplo di otto, con la convenzione che tutti i frammenti sono multipli di otto, in seguito nel campo 
\textit{flag} di 3 bit, si specifica se il pacchetto può essere frammentato. Il primo bit deve essere riservato e sempre pari a zero, i seguenti due bit chiamati DF, \textit{Don't Fragment}, e MF, \textit{More Fragment}, indicano se il pacchetto può essere frammentato, il primo, oppure se viene seguito da altri frammenti, il secondo. Il campo MF quindi permette di riconoscere l'ultimo frammento di un pacchetto. 
Se un pacchetto non può essere frammentato, allora si preferisce scartarlo. 
Oltre all'identificatore per stabilire l'univocità del pacchetto si può utilizzare l'indirizzo del mittente. 

Sull'ultimo frammento si può inserire un numero di byte arbitrario, poiché non è necessario l'\textit{offset}, ma solamente la specifica nel campo MF. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Frammentazione \textcolor{BurntOrange}{IPv4} \textcolor{Brown}{pdu}}%  
\end{figure}

Il campo \textit{total length}, di 16 bit, indica la dimensione massima del pacchetto, al massimo di 65553 byte, ma molto spesso è frammentato e minore di questo valore. 
Il campo \textit{time to live}, di 8 bit, rappresenta il tempo di vita del pacchetto, e quando raggiunge zero viene scartato, ed il \textit{router} invia una avvertimento al mittente. 
Il valore contenuto viene decrementato ad ogni salto o \textit{hop}. Quindi un pacchetto in \textit{internet} può effettuare al massimo 255 salti, il valore massimo contenuto nel campo \textcolor{LimeGreen}{ttl}. Nonostante la dimensione della rete 
\textit{internet}, l'elevata connettività permette di effettuare pochi salti. Viene imposto un limite per impedire che alcuni pacchetti entrino in loop. Non deve essere possibile 
in nessun caso che un pacchetto giri in eterno sulla rete. 

Il campo \textit{protocol} indica il protocollo di livello superiore a cui è indirizzato il contenuto del campo dati del pacchetto, i possibili valori vengono definiti dalla IANA. Molto 
spesso il pacchetto di livello superiore contenuto è di protocollo \textcolor{Bittersweet}{TCP}, con valore 6. 
Il campo \textit{\textit{header} checksum} do 16 bit è analogo al campo RCS del livello due, riguarda solamente l'intestazione e deve essere ricalcolata ad ogni hop, poiché cambia il contenuto del campo \textcolor{LimeGreen}{ttl}. Le tecnologie più recenti permettono di non essere calcolato nuovamente ad ogni hop.

In seguito si specificano il mittente ed il destinatario del pacchetto. Si possono specificare campi addizionali relativi a possibili opzioni, questi devono obbligatoriamente costituire multipli di 32 bit, per cui si può aggiungere del \textit{padding} per allinearsi ad una \textit{long word}. 
Ogni opzione comincia con un byte che ne specifica il codice. Queste opzioni possono specificare quanto sia segreto il pacchetto, il \textit{source routing} ovvero il cammino completo. Si può specificare una sequenza di stazioni intermedie da attraversare obbligatoriamente, opzione meno stringente del \textit{source routing}. Si può indicare che ogni \textit{router} attraversato debba specificare il proprio indirizzo e/o un \textit{timestamp}. Non è obbligatorio per gli \textcolor{Emerald}{is} di rispettare queste opzioni, poiché sono 
operazioni aggiuntive che richiedono calcolo ulteriore e potrebbero rallentare il meccanismo di inoltro. 

Questi campi costituiscono l'\textit{header} del pacchetto, in seguito vengono inseriti i dati.  

\subsubsection{Indirizzamento \textcolor{BurntOrange}{IPv4}}

Gli indirizzi \textcolor{BurntOrange}{IPv4} sono associati alle schede di rete e non alle macchine \textit{host}, sono di 4 byte ed univoci a livello mondiale. Per comodità 
sono rappresentati da quattro numeri decimali, separati da punti, spesso gli vengono assegnati nomi simbolici. 

Non sono assegnati in modo casuale, ma le stesse zone geografiche hanno gli stessi indirizzi, per facilitare la commutazione. Indirizzi sulla stesse rete locale condividono il prefisso, un gruppo 
di macchine è quindi identificato dal suo prefisso. Nei \textit{router} quindi si 
possono inserire delle tabelle di indirizzi, raggruppati in \textit{net}. Indirizzi nella stessa \textit{net} sono raggruppati su una stessa rete fisica. 

La convenzione consiste di completare i prefissi con tutti zeri per realizzare un indirizzo \textcolor{BurntOrange}{IPv4} legittimo da poter utilizzare. Questo valore ottenuto si utilizza per 
denotare l'intera \textit{net} e \textcolor{violet}{LAN}, e non può essere utilizzato per indirizzare le interfacce della \textcolor{violet}{LAN}. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Tabelle di Instradamento \textcolor{BurntOrange}{IPv4}}%
\end{figure}

L'indirizzo \textcolor{BurntOrange}{IPv4} ha due funzioni, di identificare un'interfaccia nella rete e di locazione di gruppi di indirizzi in posizione geografiche omogenee nella rete. 
Nei primi anni di \textit{internet} gli indirizzamenti \textcolor{BurntOrange}{IPv4} erano divisi in cinque classi, con prefissi di diversa lunghezza, rappresentate da cinque lettere A, B, C, D, E. Questo tipo di indirizzamento viene chiamato \textit{classfull}. 
Se l'indirizzo iniziava con il primo bit a zero, allora la sua parte prefisso si estendeva al primo byte, mentre i restanti consistevano in un identificatore delle macchine \textit{host} sulla 
\textcolor{violet}{LAN}. Se il primo bit è uno ed il secondo è uno zero, allora il prefisso si estende al primo ed al secondo byte. Quando il terzo bit è a zero il prefisso si 
estende fino al terzo byte. Questi tipi di indirizzi si chiamano di classe A, B e C. Gli indirizzi di classe D hanno il terzo bit pari a zero e individuano 
indirizzi di tipo \textit{multicast}. La classe E con il quarto bit a zero venne riservata invece per usi futuri. 


\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Indirizzamento \textcolor{BurntOrange}{IPv4} \textit{classfull}}%
\end{figure}


Il problema di questo approccio consiste nello spreco di byte per la prima classe, poiché non esiste una \textcolor{violet}{LAN} contenente $2^{24}$ indirizzi. Per cui si è introdotto 
l'indirizzamento \textcolor{BurntOrange}{IPv4} \textit{classless} che utilizza un'altra sequenza di bit accanto all'indirizzo chiamata \textit{netmask}, questo consente una lunghezza arbitraria del prefisso. Questa \textit{netmask} è composta da una sequenza di quattro byte composta da due sequenze contigue di uno, seguita da una composta da zeri. Si specifica una \textit{netmask} dal numero di uno che la compongono. Queste vengono normalmente scritte nella documentazione di rete come numeri decimali, 
con la stessa convenzione degli indirizzi \textcolor{BurntOrange}{IPv4}. 

Poiché tutti gli indirizzi di uno stesso prefisso hanno la stessa \textit{netmask} si può parlare di \textit{netmask} di un prefisso. 
La \textit{netmask} di un prefisso si può rappresentare come un numero, dopo l'indirizzo, che indica la lunghezza del prefisso, separato da una barra \texttt{/}. 
Due indirizzi \textcolor{BurntOrange}{IPv4} che si trovano sullo stesso prefisso hanno la stessa \textit{netmask}, generano lo stesso valore se messi in \textit{and} bit a bit con la \textit{netmask} 
relativa. 
Due indirizzi appartenenti a diverse \textcolor{violet}{LAN} producono risultati diversi se messi in \textit{and} bit a bit sulla stessa \textit{netmask}. Questo vale solo se gli indirizzi vengono 
assegnati in modo che siano tutti disgiunti tra di loro. La responsabilità di assegnare gli indirizzi appartiene ad organizzazioni internazionali come la RIPE. 

La configurazione delle interfacce degli \textcolor{Periwinkle}{es} prevede la specifica della \textit{netmask} della \textit{net} di appartenenza, per cui mettendo in \textit{and} l'indirizzo del destinatario, 
l'\textcolor{Periwinkle}{es} è in grado di identificare se si tratta di un indirizzo locale o remoto. Se il destinatario è locale viene inviato tramite trasmissione diretta al destinatario, 
se è remoto invece, viene inviato al \textit{default gateway} della \textcolor{violet}{LAN}, un \textit{router} particolare. 
Il problema in questo approccio è che non si conosce la \textit{netmask} del destinatario e si ricava il prefisso del destinatario dalla \textit{netmask} dell'\textcolor{Periwinkle}{es}, 
infatti si potrebbe ricavare il prefisso errato applicando l'\textit{and} bit a bit tra l'indirizzo del destinatario e la \textit{netmask} locale. L'ipotesi che gli 
indirizzi vengono assegnati in modo disgiunto permette di risolvere questo problema di ricavare il prefisso sbagliato. L'unico caso che quest'ipotesi non risolve è quando il prefisso calcolato del destinatario è diverso da quello reale, ma comunque diverso 
da quello locale. Questo non rappresenta un problema poiché il prefisso individuato è remoto, quindi verrà inviato indipendentemente al \textit{default gateway}. 
Non da errore dal punto di vista della località o non località del destinatario di un pacchetto. 

Dentro ad un \textit{router} è presente una tabella di instradamento che controlla tramite un'azione chiamata \textcolor{Bittersweet}{IP} \textit{lookup}. Questa tabella contiene singoli prefissi con la relativa \textit{netmask}, che 
vengono confrontati bit a bit con l'indirizzo destinatario, sulla relativa \textit{netmask}. Non appena si rileva un riscontro il pacchetto viene inviato su quella linea, 
altrimenti il pacchetto viene scartato. I prefissi vengono ordinati rispetto alla loro lunghezza. Sull'ultima riga 0.0.0.0/0, chiamata rotta di \textit{default}, non sempre presente, 
viene prodotto un riscontro con ogni indirizzo. Se è presente quindi nessun pacchetto può essere scartato. 
Si utilizza questa rotta di \textit{default} poiché la tabella di instradamento non può contenere tutti i prefissi dell'intera rete. 
Oltre alla linea di inoltro rappresentata dall'interfaccia del \textit{router}, è presente un altro campo chiamato \textit{next-hop} che specifica a quale \textit{router} inviare il pacchetto 
in base all'indirizzo del destinatario, per distinguere pacchetti destinati alla stessa linea di inoltro. Tuttavia sono presenti eccezioni notevoli su questo schema. 

Le operazioni eseguita da un \textcolor{Periwinkle}{es} per l'inoltro di un pacchetto possono essere pensate in termini di accesso ad una tabella di instradamento. Può 
essere considerato come una macchina con una tabella di instradamento con informazioni veramente essenziali. 
Su ogni macchina l'interfaccia lo di \textit{loopback} si identifica con l'indirizzo \texttt{127.0.0.0/8}, ed il pacchetto ``rimbalza'' e torna indietro. Tramite quest'interfaccia 
due applicazioni su una stessa macchina possono comunicare disaccoppiandole fortemente, quindi senza utilizzare l'API, solamente attraverso dei pacchetti inviati sulla rete.
Questo indirizzo è un prefisso, non è un vero indirizzo, l'indirizzo attribuito a quest'interfaccia di loopback corrisponde di default al primo indirizzo 
disponile: \texttt{127.0.0.1}. si possono inserire più interfacce di \textit{loopback} su una stessa macchina, sempre all'interno dello stesso prefisso. 

\begin{center}
    \begin{tabular}{|c|c|c|c|}
        \hline
        Network&Netmask&Interfaccia&Next-Hop\\
        \hline
        Prefisso dell'\textcolor{Periwinkle}{es}&Netmask dell'\textcolor{Periwinkle}{es}& \texttt{eth0}& Direct Connection\\\hline
        \texttt{127.0.0.0}&\texttt{255.0.0.0}&lo&Direct Connection\\\hline
        \texttt{0.0.0.0}&\texttt{0.0.0.0}&\texttt{eht0}&Rotta di \textit{Default}\\\hline        
    \end{tabular}
\end{center}

Alcuni indirizzi hanno un significato particolare e sono dedicati. Per cui non è possibile assegnare indirizzi contenenti solo \texttt{0} o \texttt{255}. L'indirizzo composto da tutti \texttt{1}, dopo il prefisso rappresenta un indirizzo \textit{broadcast} sulla \textcolor{violet}{LAN}, per questo non 
si può utilizzare solamente uno all'interno di un indirizzo. 
Indirizzi di prefisso \texttt{10.0.0.0/8} sono indirizzi privati non validi nella rete, che possono essere utilizzati per comunicare all'interno di una \textcolor{violet}{LAN}, possono essere 
associati ad indirizzi validi per comunicare verso l'esterno. 
L'indirizzo \texttt{172.16.0.0/12} rappresenta macchine visibili solo localmente, analogamente indirizzi \texttt{192.168.0.0/16} sono indirizzi utilizzabili nella comunicazione tra 
macchine nella stessa \textcolor{violet}{LAN}. Il provider trasforma questi indirizzi privati in indirizzi validi per comunicare in \textit{internet}.

In un processo chiamato \textit{sub-netting} è possibile spezzare l'indirizzo privato \texttt{10.0.0.0/8} per permettere di comunicare tra di loro a varie macchine di una stessa azienda 
o organizzazione. 

Le organizzazioni che assegnano gli indirizzi utilizzano un meccanismo che divide gli indirizzi in grandi pezzi da \texttt{/8}, assegnati ad aree geografiche. Delle organizzazioni 
delegate ad ogni area geografica assegnano gli indirizzi a chi lo richiede:
\begin{itemize}
    \item ARIN, \textit{American Registry for Internet Numbers}: per il Nord America;
    \item RIPE, \textit{(Resèaux IP Europèen) Coordination Center}: per l'Europa;
    \item APNIC, \textit{Asia Pacific network Information Center}: per il Pacifico e l'Asia;
    \item AfriNIC, \textit{Africa NIC}: per l'Africa;
    \item LACNIC, \textit{Latin American and Caribbean NIC}: per l'America Latina ed i Caraibi. 
\end{itemize}

Quando finiscono la loro sezione di spazio di indirizzi, richiedono all'IANA, \textit{Internet Assigned Numbers Authority} 
l'organizzazione globale per assegnare gli indirizzi \textcolor{BurntOrange}{IPv4}, ulteriore spazio. 
Attualmente questi indirizzi si stanno esaurendo quindi queste organizzazioni potrebbero non essere in grado di assegnare gli indirizzi richiesti. Attualmente l'IANA ha assegnato tutti i possibili indirizzi \texttt{/8}, quindi ulteriori indirizzi devono essere assegnati dalle organizzazioni delegate per ogni area geografica effettuando operazioni di \textit{sub-netting}. 


Gli \textcolor{Periwinkle}{es} tendono ad avere più schede di rete, sulla stessa macchina, ma anche se sono presenti più schede l'\textcolor{BurntOrange}{IPv4} ne utilizza una sola alla volta, mentre le altre sono 
inattive. Questo poiché alla sua creazione, non era immaginabile che una stessa macchina potesse contenere più schede di rete. Per cui i costruttori di macchine 
inseriscono una gerarchia tra le varie schede di rete. Nonostante questo molte applicazioni cercano comunque di utilizzare più schede di rete in parallelo su un singolo \textcolor{Periwinkle}{es}. 

\subsubsection{Il Protocollo \textcolor{Red}{ARP}}

Il protocollo \textcolor{Red}{ARP} di terzo livello, definito nella RFC 826 risolve il problema di associare indirizzi \textcolor{DarkOrchid}{MAC} ad indirizzi \textcolor{BurntOrange}{IPv4}. 

Se bisogna inviare un pacchetto all'intero di una rete locale bisogna effettuare una consegna diretta, ovvero spedire il pacchetto direttamente alla macchina del 
destinatario. Questa consegna viene effettuata specificando al livello 2 l'indirizzo \textcolor{DarkOrchid}{MAC} del destinatario, ma è noto solamente l'indirizzo \textcolor{BurntOrange}{IPv4}, quindi 
si utilizza il protocollo \textcolor{Red}{ARP} per identificarlo. 
\textcolor{Red}{ARP} invia un pacchetto \textit{broadcast}, \textcolor{Red}{ARP} \textit{request}, su tutte le macchine della \textcolor{violet}{LAN}, a questo risponderanno solamente le macchine aventi quell'indirizzo \textcolor{DarkOrchid}{MAC}. Tutte le macchine sulla \textcolor{violet}{LAN} 
sono costrette ad aprire i pacchetti, quindi viene generata un'interruzione \textit{hardware} e deve essere gestita dal sistema operativo anche se il pacchetto non 
appartiene alla macchina. Ogni scheda di rete è costretta ad analizzare ed aprire i pacchetti che arrivano ad essa, uno dei principi dietro agli attacchi DOS. Infatti se eccessivo potrebbe provocare la perdita di prestazioni della rete locale. 
Questo processo provoca un'interruzione a bordo di tutti gli \textit{host} della \textcolor{violet}{LAN}, anche attraverso gli \textit{hub} e gli \textit{switch}; i pacchetti \textcolor{Red}{ARP} fermati solamente 
dai \textit{router}. 

Per evitare questo processo costantemente ed intasare la rete locale si utilizza un processo di \textit{caching}, dove gli indirizzi noti vengono memorizzati. Quando un \textit{host} riceve un pacchetto 
\textcolor{Red}{ARP} \textit{request} dedicato a sé stesso invia un'\textcolor{Red}{ARP} \textit{reply}. 
Gli \textit{host} che utilizzano \textcolor{Red}{ARP} hanno a disposizione una \textit{cache} dove si possono salvare queste corrispondenze tra \textcolor{BurntOrange}{IPv4} e \textcolor{Red}{ARP}. 

Su una macchina Linux il comando \verb|arp -a| permette di visualizzare la lista di queste associazioni. 

Questi pacchetti sono contenuti direttamente nel pacchetto di livello 2, quindi sono presenti gli indirizzi \textcolor{BurntOrange}{IPv4} e \textcolor{DarkOrchid}{MAC} dei destinatari e mittenti. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Struttura \textcolor{Red}{ARP} \textcolor{Brown}{pdu}}%
\end{figure}

I campi \textit{hardware} e \textit{protocol} specificano il tipo di indirizzi di livello due e di livello tre, mentre i campi hlen e plen specificano la lunghezza dei due indirizzi. Venne 
definito in questo modo modulare poiché si pensava che la lunghezza degli indirizzi sarebbe cambiata. Si utilizzano quindi 
campi di lunghezza variabile per memorizzare questi indirizzi che possono variare. 
In IEEE 802 hlen è di 48 bit, mentre plen in \textcolor{BurntOrange}{IPv4} è di 32 bit. 

Nel campo \textit{operation} è specificato se il pacchetto è una \textit{request} o \textit{reply}. I campi \textit{sender} ia e ha sono rispettivamente l'indirizzo livello due e tre del mittente. Il campo \textit{target} ia contiene l'indirizzo di livello tre della macchina di cui si vuole conoscere l'indirizzo di livello due, solo nel caso di una \textit{request}. 

Mentre se l'indirizzo di livello tre è esterno alla \textcolor{violet}{LAN}, il protocollo \textcolor{Red}{ARP} allo stesso modo deve individuare l'indirizzo \textcolor{DarkOrchid}{MAC} del \textit{router}. Questo protocollo \textcolor{Red}{ARP} appartiene al livello tre della 
pila \textcolor{blue}{ISO-OSI}, ed è un protocollo di supporto per l'\textcolor{BurntOrange}{IPv4}. 
Quando un pacchetto viene ricevuto da un \textit{router}, vengono effettuate le stesse operazioni descritte per gli \textcolor{Periwinkle}{es}, per individuare l'indirizzo \textcolor{DarkOrchid}{MAC} della macchina. 
Ogni salto di un pacchetto comporta una \textcolor{Red}{ARP} \textit{request}, una \textcolor{Red}{ARP} \textit{reply} e l'invio del pacchetto, se l'indirizzo \textcolor{DarkOrchid}{MAC} non è contenuto nella \textit{cache} della macchina \textit{host}. 

\subsubsection{Il Protocollo \textcolor{Maroon}{ICMP} per \textcolor{BurntOrange}{IPv4}}

Il protocollo \textcolor{Maroon}{ICMP}, \textit{Internet Control Massage Protocol}, per \textcolor{BurntOrange}{IPv4} realizza due operazioni per le reti, ed ha un approccio \textit{best effort}, effettua dei tentativi al meglio delle sue capacità prima di scartare il pacchetto. 

Provvede ad un piccolo servizio di rilevazione degli errori, inoltre consente di inviare e richiedere pacchetti ed ottenere informazioni. 
Mentre \textcolor{Red}{ARP} viaggia direttamente dentro il livello 2, i pacchetti \textcolor{Maroon}{ICMP} viaggiano dentro pacchetti \textcolor{BurntOrange}{IPv4}. Questo protocollo fornisce informazioni di controllo e non offre direttamente servizi di consegna di pacchetti, si comporta quindi come un protocollo ausiliario di \textcolor{BurntOrange}{IPv4}. 

Le regole sul comportamento di questo protocollo vennero definite nella RFC 792. La prima regola impone che nessun messaggio \textcolor{Maroon}{ICMP} viene generato a seguito di 
rilevati errori su altri messaggi \textcolor{Maroon}{ICMP}. La seconda regola impone che se il pacchetto viene frammentato, solo il primo frammento può generare un messaggio di errore \textcolor{Maroon}{ICMP}. 
La terza regola impone che i pacchetti \textit{broadcast} e \textit{multicast} non generano pacchetti \textcolor{Maroon}{ICMP}. 
Si utilizzano queste regole per non generare eccessivo traffico sulla rete. 

Il pacchetto \textcolor{Maroon}{ICMP} viaggia all'interno del campo dati di un pacchetto \textcolor{BurntOrange}{IPv4}, poiché se viene sollevato un errore, deve poter tornare al mittente, quindi deve 
necessariamente viaggiare dentro un pacchetto \textcolor{BurntOrange}{IPv4}, per conoscere l'indirizzo di ritorno. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{\textcolor{Maroon}{ICMP} \textcolor{Brown}{pdu}}%
\end{figure}

Esistono diversi tipi di pacchetti di errore che \textcolor{Maroon}{ICMP} può generare. 
I messaggi di primo tipo sono messaggi di \textit{destination unreachable}, in questo caso i pacchetti vengono scartati poiché la destinazione non è raggiungibile per diversi 
motivi:
\begin{itemize}
    \item \textit{Network Unreachable}: un \textit{gateway} vede la rete dov'è destinato il pacchetto a distanza infinita; ovvero un \textit{router} sta entrando nella tabella di instradamento e l'indirizzo non effettua alcun \textit{match};
    \item \textit{Host Unreachable}: l'\textit{host} a cui è destinato il pacchetto non risponde ad una chiamata \textcolor{Red}{ARP}. Il \textit{router} a cui è arrivato il pacchetto tenta di effettuare una chiamata \textcolor{Red}{ARP} per inviare direttamente il pacchetto, ma questa fallisce quindi scarta il pacchetto;
    \item \textit{Protocol Unreachable}: dentro il pacchetto \textcolor{BurntOrange}{IPv4} è presente un campo che identifica il protocollo a cui va mandato il pacchetto, se questo protocollo non è conosciuto allora viene sollevato questo messaggio di errore;
    \item \textit{Port Unreachable}: la \textit{port} a cui è spedito il pacchetto non è raggiungibile;
    \item \textit{Fragmentation Needed and DF Set}: se il pacchetto non può essere frammentato, ma  deve essere frammentato per passare attraverso la \textcolor{RoyalPurple}{MTU}, quindi viene scartato. 
\end{itemize}

Altri messaggi sono di tipo tempo scaduto, se il valore del \textcolor{LimeGreen}{ttl} arriva a zero, il pacchetto viene scartato con un errore di tipo \verb|TIME_EXCEEDED|. 
Un messaggio di redirezione può essere inviato da un \textit{router} per indicare dove bisogna reindirizzare il traffico, indicando all'\textcolor{Periwinkle}{es} una strada più favorevole. 
Messaggi di \textit{echo} rappresentano risposte e richieste. Possono essere \verb|ECHO_REQUEST| ed \verb|ECHO_REPLY|, una richiesta ed una relativa risposta di \textit{echo} per controllare 
la raggiungibilità di un \textit{host}. Oppure possono essere dei \verb|TIMESTAMP_REQUEST| e \verb|TIMESTAMP_REPLY|, come \texttt{ECHO}, per fornire informazioni sull'orario di invio e sulla misurazione della velocità del collegamento, ed un'approssimativa sincronizzazione. 

Il comando \verb|ping|, seguito da un indirizzo, permette di effettuare quest'ultima operazione: invia un pacchetto \textcolor{Maroon}{ICMP} di tipo \textit{echo} ad una macchina e questa, se è raggiungibile, tenta di 
inviare i pacchetti di ritorno \textcolor{Maroon}{ICMP}. 
\begin{minted}{powershell}
    \prompt> ping 127.0.0.1
\end{minted}
Poiché l'indirizzo specificato è l'indirizzo di \textit{loopback} nessun pacchetto dovrebbe venire perso, e vengono ricevuto con un ritardo pressoché nullo. 
Questo comando è disponibile nella quasi totalità dei sistemi operativi moderni, ed ha l'obiettivo di verificare se un dato indirizzo \textcolor{Bittersweet}{IP} è 
raggiungibile ed il ritardo necessario per raggiungerlo. 

Quando termina il comando di ping viene visualizzato un report che indica il numero di pacchetti inviati, persi, il tempo totale impiegato, ed il tempo di andata e 
ritorno in media, al massimo e la deviazione media. 
Il comando ping è realizzato con una \verb|fork()|, dove il primo processo si occupa di lanciare i pacchetti, mentre il secondo riceve i pacchetti e calcola le statistiche. Quando i pacchetti vengono 
inviati o ricevuti vengono memorizzati. I pacchetti inviati si possono visualizzare con il comando \verb|tcpdump| specificando solamente i pacchetti di tipo \textcolor{Maroon}{ICMP}:
\begin{minted}{powershell}
    \prompt> tcpdump -n "icmp"
\end{minted}

Se si effettua un ping su un indirizzo \textit{broadcast}, considera solo la risposta della prima macchina, mentre tutti gli altri messaggi di ritorno provenienti dalle 
altre macchine vengono considerati come duplicati. Per terminare l'esecuzione del comando si utilizza la sequenza ``Ctrl + C''. 


Il comando traceroute è disponile nella quasi totalità delle macchine, attraverso questo comando si vuole determinare quali sono i \textit{router} effettivamente attraversati 
per raggiungere una destinazione \textcolor{Bittersweet}{IP}. 
Quest'operazione viene eseguita inviando pacchetti di \textcolor{LimeGreen}{ttl} molto basso, incrementandolo ad ogni pacchetto, in modo che i \textit{router} che scartano il pacchetto inviano 
il pacchetto \verb|TIME_EXCEEDED| alla macchina mittente. In questo modo si può ottenere progressivamente la sequenza di \textit{router} che il pacchetto deve 
attraversare per arrivare all'indirizzo \textcolor{Bittersweet}{IP} destinatario. 
Nella commutazione a datagramma, i diversi pacchetti potrebbero attraversare strade diverse, e quindi i vari pacchetti della sequenza potrebbero restituire \textit{router} appartenenti a strade diverse. Per cui non è garantito che l'informazione così ottenuta sia corretta. Sono sicuramente corretti per i percorsi dei singoli pacchetti, ma non è garantito che il percorso finale ottenuto rappresenti la sequenza di \textit{router} effettivamente attraversata da ogni pacchetto. 

Il comando nei sistemi Linux si chiama \verb|traceroute|, e \verb|tracert| su Windows, seguito dall'indirizzo \textcolor{Bittersweet}{IP} di destinazione. Il tempo di ritardo è variabile 
poiché i \textit{router} non hanno come compito principale l'inoltro dei messaggi di errore. Quindi quando il \textit{router} non sta inoltrando altri pacchetti può gestire 
i pacchetti scartati ed inoltrare i pacchetti \textcolor{Maroon}{ICMP}. Di seguito una possibile implementazione in pseudocodice del comando:

\begin{minted}{java}
    traceroute(IP)
        for(x = 1; replyIP != IP; x++)
            ttl = x
            for(n = 1; n < 3; n++)
                sendRequest(ttl)
                if(reply == TIME_EXCEEDED)
                    print(rtt, replyIP)
                else
                    print("*")
\end{minted}

Quando i pacchetti di risposta non vengono rilevati dopo un tempo definito di pochi secondi, vengono segnati tramite il carattere \verb|*|. I \textit{router} che non inviano i 
pacchetti \textcolor{Maroon}{ICMP} sono \textit{router} che non si vogliono mostrare alla rete, quindi scartano i pacchetti senza inviare risposte \textcolor{Maroon}{ICMP}. Questi \textit{router} generalmente si trovano tra i primi 
hop, di accesso diretto alla rete dell'\textcolor{teal}{ISP}. 
Il contenuto dei pacchetti inviati è arbitrario, poiché sono destinati ad essere buttati. Ma generalmente si utilizzano due tipi di pacchetti, una \verb|ECHO_REQUEST|, 
a cui il destinatario risponde con una \verb|ECHO_REPLY|, oppure viene inviato un pacchetto \textcolor{Fuchsia}{UDP}, un protocollo di livello quattro. 

Effettuando un'operazione \verb|tcpdump| si possono osservare a gruppi di tre i pacchetti inviati con i rispettivi \textcolor{LimeGreen}{ttl}. 
Studiare le reti corrisponde a studiare le varie apparecchiature e gli strumenti di supporto come questi appena descritti che popolano le reti. 

\subsubsection{I Protocolli \textcolor{OliveGreen}{IPv6} e \textcolor{SeaGreen}{ICMPv6}}

Gli indirizzi \textcolor{BurntOrange}{IPv4} si stanno esaurendo, già nel 2010 la IANA ha allocato le ultime \verb|/8| disponibili attribuendole ai registri continentali. Alla fine del 2020 il registro 
europeo ha allocato i suoi ultimi indirizzi disponibili. Gli ultimi indirizzi sono essenzialmente esauriti, ma ci sono registri più avanti di altri nella 
distribuzione. \textcolor{OliveGreen}{IPv6} è alternativo rispetto a \textcolor{BurntOrange}{IPv4}, per loro natura realizzano due reti disgiunte, che non possono comunicare tra di loro. \textcolor{OliveGreen}{IPv6} ha varie 
caratteristiche interessanti, inoltre ha indirizzi di 128 bit, e sta progressivamente sostituendo gli indirizzi \textcolor{BurntOrange}{IPv4}. 
IPv5 non è mai esistito, poiché venne realizzato un protocollo specifico dal punto di vista applicativo, che utilizzava un nuovo protocollo di livello 3 il cui nome 
poteva sembrare simile ad IPv5 quindi per evitare confusione venne chiamato \textcolor{OliveGreen}{IPv6}, ``saltando'' la versione 5. 
\textcolor{BurntOrange}{IPv4} e \textcolor{OliveGreen}{IPv6} sono destinati a convivere per anni, entrambi protocolli di livello tre, i loro pacchetti vengono gestiti separatamente dagli \textcolor{Periwinkle}{es} ed \textcolor{Emerald}{is} e per mantenere la rete attiva continueranno ad essere supportati ed utilizzati, anche all'avvento di nuovi protocolli di livello tre. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Struttura \textcolor{OliveGreen}{IPv6} \textcolor{Brown}{pdu}}%
\end{figure}

Un pacchetto \textcolor{OliveGreen}{IPv6} ha un \textit{header} di struttura fissa di 40 byte, per evitare di creare problemi ad eventuali \textit{router} attraversati. Alcune caratteristiche di \textcolor{BurntOrange}{IPv4} 
spariscono o cambiano nome e vengono introdotti nuovi campi. Viene rimosso il campo per le opzioni. 
Il campo \textit{ver} versione di 4 bit, di valore 6; analogo al campo \textit{version} nei pacchetti \textcolor{BurntOrange}{IPv4}. Non vengono distinti in base a questo campo da \textcolor{OliveGreen}{IPv6}, ma dal campo \textcolor{CadetBlue}{LLC}. Il campo \textit{traffic class} 
di 8 bit ha sostanzialmente le stesse funzioni di \textit{type of service} di \textcolor{BurntOrange}{IPv4}. Il campo \textit{flow label} di 20 bit viene utilizzato per distinguere un flusso, ma ancora non 
ha uno scopo definito. I \textit{router} attraversati dovrebbero gestire pacchetti dello stesso flusso allo stesso modo. \`{E} un campo il cui utilizzo non è ancora 
chiaro a livello applicativo, ma è utile per certi aspetti di sicurezza. Il campo \textit{payload length} di 16 bit è analogo al campo \textit{length} in \textcolor{BurntOrange}{IPv4}. Il campo 
\textit{next header} di 8 bit individua il protocollo di livello superiore contenuto, simile al campo \textit{protocol} in \textcolor{BurntOrange}{IPv4}. Si utilizza in \textcolor{OliveGreen}{IPv6} anche per specificare delle 
opzioni inserendo una codifica per identificarle all'interno del pacchetto. 
Il campo \textit{hop limit} è il \textcolor{LimeGreen}{ttl}, di 8 bit, come in \textcolor{BurntOrange}{IPv4}. Seguono i campi degli indirizzi di mittente e destinazione di 16 byte.
I pacchetti \textcolor{OliveGreen}{IPv6} non possono essere frammentati, quindi non sono presenti i campi corrispondenti alla 
frammentazione in \textcolor{BurntOrange}{IPv4}. Se questi pacchetti incontrano un \textit{router} con un \textcolor{RoyalPurple}{MTU} minore vengono scartati. La frammentazione deve essere effettuata a livello degli \textcolor{Periwinkle}{es}, esistono in 
\textcolor{OliveGreen}{IPv6} protocolli che individuano in un cammino la \textcolor{RoyalPurple}{MTU} minima, e quindi l'\textcolor{Periwinkle}{es} è in grado di creare pacchetti di lunghezza adeguate per passare attraverso l'intero percorso. 
Si suppone che i controlli di livello 2 e 4 siano sufficienti, quindi sparisce la \textit{checksum} di \textcolor{BurntOrange}{IPv4}, non è presente il campo che specifica la lunghezza dell'intestazione, poiché 
la lunghezza è fissa in \textcolor{OliveGreen}{IPv6}. In termini di intestazione è un protocollo semplice, rispetto ad \textcolor{BurntOrange}{IPv4}. 

Gli indirizzi \textcolor{OliveGreen}{IPv6} sono molto diversi da \textcolor{BurntOrange}{IPv4}, avendo molti bit in più sarebbe più difficile rappresentarli in decimale, quindi vengono rappresentati in 8 numeri 
esadecimali da quattro cifre ciascuno separati da due punti, ogni numero quindi rappresenta 16 bit. Questa rappresentazione consente di non effettuare conversioni di base, da binario a decimale e viceversa. 

La scrittura può essere semplificata, rappresentando zeri consecutivi con un singolo zero, solo se antecedenti da altri zeri. Generalmente si omettono 
gruppi consecutivi di 16 bit contenenti soltanto zeri, si omettono anche i due punti di separazione. Questa notazione è utilizzabile una sola volta all'interno di 
un indirizzo, per evitare ambiguità. L'interfaccia di loopback è \texttt{::1}, e rappresenta l'indirizzo \texttt{0:0:0:0:0:0:0:1}, analogo di \texttt{127.0.0.1} in \textcolor{BurntOrange}{IPv4}. 

Per i prefissi si utilizza la stessa notazione \texttt{/} usata in \textcolor{BurntOrange}{IPv4}, con prefissi di lunghezza massima di 64 bit. Una \textit{netmask} non è rappresentata mai nel formato dove 
sono espliciti i suoi bit, si usa solamente la notazione barra. 

Anche in \textcolor{OliveGreen}{IPv6} ci sono indirizzi \textit{unicast} e \textit{multicast}, ma non sono presenti indirizzi \textit{broadcast}. Si cerca di stabilire con chi si vuole dialogare in maniera più selettiva. Tuttavia questa regola ha delle interpretazioni piuttosto lasche. 
Sono presenti due tipi fondamentali di indirizzi \textit{unicast} sono \textit{Global  Unicast}, indirizzi utilizzabili in \textit{internet}, oppure indirizzi simili agli indirizzi \textcolor{BurntOrange}{IPv4} privati, con qualche differenza significativa, chiamati \textit{Link-Local}, utilizzabili solo nell'ambito della \textcolor{violet}{LAN}. 
In \textcolor{OliveGreen}{IPv6} indirizzi \textit{Link-Local} sono usati sempre, a differenza degli indirizzi privati in \textcolor{BurntOrange}{IPv4}, e permettono soltanto di dialogare con altre macchine sulla stessa \textcolor{violet}{LAN}. 
Nel mondo \textcolor{OliveGreen}{IPv6} \textit{link} e \textcolor{violet}{LAN} sono sinonimi, quindi non vengono chiamati \textcolor{violet}{LAN}-\textit{Local}. 

Indirizzi \textit{multicast} importanti sono \textit{Solicited Node}, \texttt{ff02::01}, indirizza tutte le macchine in una \textcolor{violet}{LAN}, essenzialmente un indirizzo \textit{broadcast}, e \texttt{ff02::02}, indirizza tutti i \textit{router} in 
una \textcolor{violet}{LAN}. 

I primi 64 bit di un indirizzo \textit{unicast} sono il prefisso, mentre i seguenti 64 bit vengono chiamati \textit{Interface Identifier}, o \textit{Interface ID}, IID, per identificare univocamente un'interfaccia. 
Questo comporta uno spreco, poiché anche se su una singola \textcolor{violet}{LAN} sono presenti poche macchine, vengono comunque utilizzati 64 bit per indirizzarle. 

Indirizzi \textit{Global Unicast} vengono assegnati da organizzazioni e registri internazionali, analogamente ad indirizzi \textcolor{BurntOrange}{IPv4}. 
Indirizzi \textit{Link-Local} hanno un prefisso \texttt{fe80::/64}, essendo privati, non possono essere usati per accedere all'esterno della rete locale. 


In \textcolor{OliveGreen}{IPv6} un'interfaccia di rete può avere diversi indirizzi, e gli spazi di indirizzamento attribuiti a due \textcolor{violet}{LAN} devono essere disgiunti. Gli indirizzi possono 
essere attribuiti alle interfacce in modo manuale oppure automatico, tramite vari meccanismi \textit{built-in} nel protocollo. Uno di questi 
è particolarmente interessante e si chiama auto-configurazione \textit{stateless}. 
Con questo meccanismo una macchina si attribuisce un indirizzo \textit{Link-Local}, senza dialogare con il \textit{router} della \textcolor{violet}{LAN}. L'interfaccia collabora con i 
\textit{router} per assegnare uno o più indirizzi \textit{Global Unicast} per poter comunicare sulla rete e sceglie i \textit{router} di \textit{default}. 
Anche in \textcolor{BurntOrange}{IPv4} sono presenti protocolli simili in modo che una macchina si auto-attribuisca un indirizzo \textcolor{BurntOrange}{IPv4}, ma questi meccanismi provengono da servizi esterni, mentre in \textcolor{OliveGreen}{IPv6} 
questi meccanismi appartengono al protocollo stesso. 

L'auto-attribuzione dell'\textit{Interface ID} può essere casuale oppure basata sull'indirizzo \textcolor{DarkOrchid}{MAC} dell'interfaccia, anche se ha un impatto negativo sulla \textit{privacy}, permette di 
realizzare indirizzi univoci, dato che lo sono tutti gli indirizzi \textcolor{DarkOrchid}{MAC} a livello globale. L'interfaccia divide l'indirizzo \textcolor{DarkOrchid}{MAC} in due parti, ciascuna di 24 bit, 
viene inserita la sequenza di 16 bit \texttt{ff:fe} tra le due parti. Al settimo bit della prima parte viene assegnato 1, poiché se l'indirizzo \textcolor{DarkOrchid}{MAC} è unico a livello 
globale quel bit vale 0. 
Questi 64 bit identificano l'indirizzo nella \textcolor{violet}{LAN}, anteponendo il prefisso \texttt{fe80::/64} per costruire l'indirizzo \textit{Link-Local}. Gli indirizzi \textcolor{DarkOrchid}{MAC} studiati si riferiscono ad uno standard EUI-48, e per tradurre indirizzi 
\textcolor{DarkOrchid}{MAC} da 64 bit si utilizza il meccanismo descritto nello standard EUI-64. 
Se viene utilizzato questo indirizzo per comunicare in \textit{internet}, viene mostrato il proprio indirizzo \textcolor{DarkOrchid}{MAC} all'intera rete, questo rappresenta un aspetto molto negativo in merito alla 
\textit{privacy}. Altrimenti algoritmi di scelta casuale possono essere utilizzati, ed includono meccanismi per evitare collisioni. 
Prima di considerare questo come indirizzo, svolge un'attività di \textit{Duplicate Address Detection}, controllando se nella stessa \textcolor{violet}{LAN} è presente un'interfaccia 
avente lo stesso indirizzo, inviando un pacchetto all'indirizzo appena costruito. Questo indirizzo è \textit{Link-Local}, quindi deve essere unico solamente all'interno della \textcolor{violet}{LAN}. 
I \textit{router} presenti sulla \textcolor{violet}{LAN} inviano periodicamente dei pacchetti di \textit{Router Advertisement} destinati ad \texttt{ff02::1}, tutte le interfacce presenti sulla \textcolor{violet}{LAN}. Le interfacce a loro volta possono sollecitare questi pacchetti tramite pacchetti \textit{Router Solicitation}. 
Nei pacchetti di \textit{Router Advertisement}, viene fornito un elenco di prefissi utilizzabili sulla \textcolor{violet}{LAN}, un tempo di validità ed una specifica se può essere utilizzato come 
\textit{router} di \textit{default}, fornisce altre informazioni utili alle interfacce ed il proprio indirizzo \textcolor{DarkOrchid}{MAC}. 

Un'interfaccia che riceve questi prefissi può attribuirsi indirizzi ulteriori rispetto a quelli \textit{Link-Local}, anteponendo uno di questi indirizzi al suo \textit{Interface ID}. 
Esistono protocolli appositi per distribuire prefissi salvati su \textit{server}, ed attribuendoli da remoto ai vari \textit{router} della \textcolor{violet}{LAN}. 


La spedizione di un pacchetto avviene come in \textcolor{BurntOrange}{IPv4}, controllando se il destinatario è sulla stessa \textcolor{violet}{LAN}, si effettua quindi spedizione diretta o spedizione 
al \textit{router} di \textit{default}. 
Le tabelle di instradamento dei \textit{router} hanno lo stesso significato delle tabelle \textcolor{BurntOrange}{IPv4}, e quindi vengono utilizzate allo stesso modo. In \textcolor{OliveGreen}{IPv6} non c'è il protocollo \textcolor{Red}{ARP} per individuare 
l'indirizzo \textcolor{DarkOrchid}{MAC} del destinatario. Il protocollo \textcolor{Red}{ARP}, invia continuamente richieste \textit{broadcast} e quindi comporta un carico elevato sulla \textcolor{violet}{LAN}. In \textcolor{OliveGreen}{IPv6} si utilizza invece 
il protocollo \textcolor{SeaGreen}{ICMPv6}, che svolge le stesse funzioni di \textcolor{Maroon}{ICMP(v4)}, ed altre funzioni, sopratutto si occupa dei servizi offerti da \textcolor{Red}{ARP} in \textcolor{BurntOrange}{IPv4}. 

Per cercare un indirizzo \textcolor{DarkOrchid}{MAC} si spedisce un pacchetto \textcolor{SeaGreen}{ICMPv6} ad un gruppo di \textit{multicast}, non \textit{broadcast}. Quando un'interfaccia si assegna un indirizzo \textcolor{SeaGreen}{ICMPv6}, 
assume anche di appartenere ad un uno specifico gruppo \textit{multicast}, chiamato \textit{Solicited Node}. Questo indirizzo è composto da un prefisso di 104 bit seguito dagli ultimi 24 bit dell'IID. I primi 16 bit di questo prefisso sono \texttt{ff02}, i seguenti 72 bit sono pari a zero e gli ultimi 16 sono \texttt{01:ff}: \texttt{ff02:0:0:0:0:1:ff00::/104}. 
La probabilità di due macchine di avere lo stesso IID sulla stessa rete locale è molto bassa, quindi questi gruppi \textit{multicast} sono molto piccoli, a volte composti da una 
singola macchina. 


Per ottenere un indirizzo \textcolor{DarkOrchid}{MAC} di un sistema, un nodo di una macchina calcola dall'indirizzo \textcolor{OliveGreen}{IPv6} del destinatario il rispettivo IID, e determina il suo gruppo \textit{multicast} di appartenenza. A questo indirizzo invia un pacchetto \textcolor{SeaGreen}{ICMPv6} di tipo \textit{Neighbor Solicitation}, specificando l'indirizzo \textit{unicast} \textcolor{OliveGreen}{IPv6} a cui rispondere. Se il destinatario è presente invia un pacchetto \textit{unicast}, con il suo 
indirizzo \textcolor{DarkOrchid}{MAC} specificato nella parte dati del pacchetto di tipo \textit{Neighbor Advertisement}. 
Questo indirizzo viene memorizzato nella \textit{Neighbor Cache}, equivalente alla \textcolor{Red}{ARP} \textit{cache}. 

Si utilizza \textit{Solicited Node} poiché un pacchetto \textit{multicast} è considerato solo da un gruppo di macchine e non dall'intera rete. 
Ma richiede un gruppo \textit{multicast} 
corrispondente a livello \textcolor{DarkOrchid}{MAC}, per evitare di dover inviare pacchetti \textit{broadcast} a livello due invece che a livello tre. Visto che l'indirizzo contiene gli ultimi bit 
dell'indirizzo è probabile che venga processato da poche schede. 

\clearpage

\section{Livello 4: Strato di Trasporto \textcolor{Bittersweet}{TCP} e \textcolor{Fuchsia}{UDP}}


Da questo livello in poi si possono sviluppare applicazioni, il servizio a questo livello deve essere affidabile, poiché si suppone che la rete lo sia. Le applicazioni infatti assumono sia affidabile. 

Offre servizi contesi con una connessione bidirezionale e contemporanea tra le due parti. 
Le primitive sono di diversi tipi, offerte ad una popolazione molto ampia di utenti-programmatori:
\begin{itemize}
    \item \texttt{listen}: Mette la macchina in attesa di ricevere una richiesta di instaurazione di una connessione;
    \item \texttt{connect}: Tenta di instaurare una connessione;
    \item \texttt{send}: Invia dati;
    \item \texttt{receive}: Riceve dati;
    \item \texttt{disconnect}: Rilascia una connessione. 
\end{itemize}
Il nome della primitiva dipende dal linguaggio di programmazione utilizzato per accedere a questa primitiva. 

La contemporaneità nella rete non è effettivamente garantita, è molto improbabile che  nello stesso istante due \textcolor{Periwinkle}{es} si comunichino a vicenda, ma sono in grado di 
ascoltare la rete ed aspettare di ricevere o inviare messaggi. Affinché la connessione sia affidabile, ogni dato inviato viene riscontrato dall'\textcolor{Periwinkle}{es} di destinazione. 

Le primitive per l'instaurazione ed il rilascio di connessioni devono essere realizzate in modo affidabile, più facile da risolvere per l'instaurazione che per il suo 
abbattimento. 

I pacchetti scambiati in una connessione sono sempre numerati a entrambi le parti in modo sequenziale, e si possono riscontrare i pacchetti inviati tramite 
\textit{acknowledgment}, analogamente ai casi precedenti. La numerazione inizia da un numero arbitrario scelto dai due \textcolor{Periwinkle}{es} su cui si basa l'instaurazione della connessione. Questo metodo viene chiamato \textit{three way handshake}. 

Dati due calcolatori, il primo sceglie un numero di sequenza arbitrario per il numero dei pacchetti $x$ ed invia una \textit{Connection Request} al secondo con il numero scelto. 
A questo punto il secondo calcolatore ricevuto il pacchetto sceglie il suo numero iniziale di sequenza $y$. Questo invia un pacchetto di tipo \textit{Connection Accepted}, 
contenente $x$ e $y$. A questo punto il primo calcolatore suppone che questi due valori siano validi ed invia un pacchetto di riscontro al secondo calcolatore con 
un pacchetto contenente $y$. Questo pacchetto finale di riscontro dovrebbe essere numerato con il valore di $x$, ma questa è una questione di convenzioni, che verrà trattata successivamente. Spesso 
il primo pacchetto dell'\textit{handshake} si chiama \textit{Data}, poiché potrebbe già contenere dei dati scambiati dal primo verso il secondo calcolatore. Questo è sicuramente non vero per il primo 
ed il secondo pacchetto della connessione. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Instaurazione di una connessione \textit{Three Way Handshake}}%  
\end{figure}

Numerare i pacchetti è molto utile, per permettere di riscontare esattamente quali pacchetti sono stati ricevuti. 

Sarebbe semplice numerare i pacchetti da zero per entrambi gli \textcolor{Periwinkle}{es}, ma utilizzando numeri diversi è possibile distinguere pacchetti scambiati da due stessi 
calcolatori, anche in tempi diversi, su connessioni diverse tra di loro. 

Rilasciare una connessione è un processo complesso, se non viene effettuato correttamente si potrebbe rischiare la perdita di alcuni dati. Se la connessione viene 
terminata in modo unilaterale, il rilascio è rudimentale, poiché il secondo calcolatore connesso potrebbe aver inviato pacchetti, nonostante la connessione sia stata 
interrotta a sua insaputa. Questi pacchetti verranno quindi persi. 
Si potrebbe utilizzare un rilascio simmetrico, dove entrambi i calcolatori si accordano per continuare ad ascoltera la connessione per un certo intervallo di tempo, per ricevere eventuali pacchetti che andrebbero altrimenti persi. Questo è un problema molto complesso, poiché non è definito in quale istante la connessione si dice completamente 
terminata. 


Questa situazione si può rappresentare in modo semplice con il problema dei due eserciti, o due generali. Si suppone esistano due eserciti, il primo numericamente 
superiore al secondo, ma diviso in due parti minori, ognuna minore del secondo. Queste due parti sono disgiunte tra di loro, e per poter battere il secondo esercito devono 
necessariamente attaccare in contemporanea, altrimenti non riuscirebbero a vincere. I generali di queste due parti del primo esercito devono comunicare spedendo 
emissari tra di loro, ma questi devono attraversare il territorio dell'esercito nemico, e potrebbero essere catturati. 
Si potrebbero inviare emissari tra le due parti per riscontrare l'arrivo dell'emissario precedente, inviando così un numero arbitrario di riscontri; ma l'ultimo generale ad inviare il suo emissario come 
riscontro non saprà mai se il messaggio è stato ricevuto. Non esiste infatti protocollo di comunicazione per garantire a questi due generali una vittoria. 

Si potrebbe allora inserire un timer, se entro un certo periodo non viene ricevuto alcun pacchetto, allora viene rilasciata la connessione. Si vorrebbe avere un tempo di \textit{timeout} molto ristretto, ma 
questo rappresenta un'euristica, non garantisce non vengano persi pacchetti. 

\subsection{\textit{Transmission Control Protocol}: \textcolor{Bittersweet}{TCP}}

Il protocollo \textcolor{Bittersweet}{TCP} viene definito negli standard RFC 793, 1122 e 1323. \textcolor{Bittersweet}{TCP} offre un servizio di trasmissione di dati affidabile bidirezionale e contemporaneo, chiamato 
\textit{full-duplex}, oppure punto-punto, \textit{host-to-host} o \textit{end-to-end}. Connessioni di tipo \textit{multicast} o \textit{broadcast} non sono supportate, può usare protocolli di livello tre 
diversi, sia \textcolor{BurntOrange}{IPv4} che \textcolor{OliveGreen}{IPv6}, tra gli altri. 


\`{E} il primo protocollo a garantire l'affidabilità della connessione, identifica i problemi dei livelli sottostanti, infatti se un pacchetto viene scartato nel percorso lo 
richiede nuovamente, e se i pacchetti arrivano disordinati li riordina. Utilizza meccanismi di \textit{acknowledgment}, ogni pacchetto viene seguito da riscontri. Una 
connessione non avviene tra due calcolatori, ma tra due processi attivi dentro una macchina. Ogni processo in una connessione è identificato dall'indirizzo \textcolor{Bittersweet}{IP} della 
macchina, ma questo non è sufficiente, quindi si utilizza un numero assegnato a ciascun processo per distinguerli, chiamato numero di porta o \textit{port}. Una volta 
stabilita la connessione, i dati allo strato \textcolor{Bittersweet}{TCP} del mittente vengono inviati correttamente allo strato \textcolor{Bittersweet}{TCP} del ricevente ed offerti al processo destinazione. Dal punto di vista 
dell'applicazione la rete non esiste, si interfaccia solamente con il livello \textcolor{Bittersweet}{TCP} del destinatario. 
Le \textit{port} sono i \textcolor{Bittersweet}{TCP} {\textcolor{cyan}{sap}}, sono numeri da 2 byte, non possono essere minori di 1024, poiché riservati a servizi standard, anche se molti altri numeri sono riservati ad altri servizi con 
un \textit{port} superiore. 
Un processo potrebbe chiedere al protocollo un certo numero di \textit{port} specifico da utilizzare e se non è già utilizzato gli viene assegnato. 

I pacchetti \textcolor{Bittersweet}{TCP} si chiamano \textit{segment}, segmenti, costituiti da un intestazione e dati opzionali. C'è un limite per i dati \textcolor{Bittersweet}{IP} di 65553 byte, un altro limite più stringente 
è dato dalle \textcolor{RoyalPurple}{MTU}. I byte a disposizione dell'applicazione per ogni pacchetto sono 1460 byte, poiché al minimo 20 sono riservati all'intestazione del livello quattro, ed altri 20 riservati 
all'intestazione \textcolor{BurntOrange}{IPv4}. 
I pacchetti non sono numerati, ma vengono numerati i byte dei pacchetti con un numero di sequenza di 32 bit, e consente di avere \textit{reset} dei numeri di sequenza 
infrequenti, rappresenta una sequenza circolare. Questi vengono riscontrati byte per byte utilizzando \textit{acknowledgment}. 

I segmenti vengono utilizzati per instaurare connessioni, spedire dati, spedire \textit{acknowledgment} o chiudere connessioni. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Struttura \textcolor{Bittersweet}{TCP} \textcolor{Brown}{pdu}}%  
\end{figure}

Ogni riga è composta da 4 byte. Nella prima sono presenti il numero di porta del sorgente e del destinatario, la seconda contiene il numero di sequenza del byte spedito, 
la terza il numero di sequenza di \textit{acknowledgment}. 
Se si usasse un intestazione per spedire ogni byte sarebbe troppo inefficiente, quindi questo numero di sequenza di byte si riferisce al primo byte del campo dati. 
Questi byte vengono numerati a partire da questo numero di sequenza specificato. L'\textit{acknowledgment} specifica l'ultimo byte che è stato riscontrato. 
Nella quarta riga, il campo hlen specifica la lunghezza dell'intestazione, res è un campo riservato, il campo \textit{code} contiene la funzione del pacchetto, il campo \textit{windows} regola il 
controllo di flusso, lungo 2 byte. 
Nella quinta riga è presente una \textit{checksum}, importante per capire se il pacchetto è integro, segue un \textit{urgent pointer} per specificare un dato importante da 
leggere appena viene ricevuto il pacchetto, entrambi di due byte. Segue una riga con le opzioni ed eventuale padding. 

Quando si riscontra un numero di sequenza in un \textit{acknowledgment} si specifica il numero del prossimo byte atteso, questo campo quindi si riferisce ai dati che viaggiano 
in direzione opposta. Il numero di sequenza inoltre stabilisce la posizione del pacchetto nel flusso di dati generato in trasmissione. 

Il nome del pacchetto per la richiesta dell'instaurazione della connessione si chiama \textit{syn}, mentre \textit{ack} per il pacchetto di riscontro. Il significato applicativo 
dei byte trasportati dal protocollo \textcolor{Bittersweet}{TCP} non è noto al protocollo stesso, o a qualunque protocollo di livello quattro, questi verano interpretati da protocolli di livello superiore. 

Il campo \textit{code} determina la funzione del pacchetto in base a quali tra questi bit è attivo, ovvero assegnato ad uno:
\begin{itemize}
    \item URG: Indica che il campo \textit{urgent pointer} è valido;
    \item ACK: Indica che il campo contenente l'\textit{ack} è valido, ovvero il riscontro contenuto deve essere considerato. Sempre valido, tranne nel primo pacchetto del \textit{three way handshake};
    \item PSH: Specifica che il pacchetto deve essere inviato velocemente;
    \item RST: Specifica di voler resettare la connessione;
    \item SYN: Indica che si vuole sincronizzare i numeri di sequenza ed il pacchetto prende il nome di \textit{syn};
    \item FIN: Indica che il mittente ha raggiunto la fine del byte stream e rilascia la connessione. 
\end{itemize}

La \textit{checksum} intessa l'intero segmento, gli indirizzi \textcolor{Bittersweet}{IP} ed il campo \textit{protocol} dei pacchetti al livello tre. Questa \textit{checksum} provoca un'invasione della gerarchie sui campi del 
terzo livello. Le opzioni specificano la negoziazione sulla massima ampiezza del campo dati nell'instaurazione della connessione. Gli \textit{host} sono obbligati ad accettare 
almeno 536 byte. 

Per ogni connessione \textcolor{Bittersweet}{TCP} utilizza dei \textit{buffer} in trasmissione ed in ricezione. Questi \textit{buffer} sono porzioni di memoria disponibile e vengono gestiti come delle code. Quando si utilizza una primitiva di invio, vengono inseriti i dati da inviare all'interno di questo \textit{buffer} e verranno inviati quando il protocollo lo riterrà opportuno. In ricezione invece l'effetto della primitiva \textit{receive} corrisponde a leggere nel \textit{buffer} per controllare se sono presenti dati da leggere, già precedentemente ricevuti, ed in caso canella il \textit{buffer}. 
Questi \textit{buffer} occupano molta memoria, due per ogni connessione \textcolor{Bittersweet}{TCP}, quindi è favorevole a terminare connessioni per liberare memoria disponibile per la macchina \textit{host}. 

Il campo \textit{window} indica la dimensione corrente del \textit{buffer} in ricezione, dopo aver ricevuto l'ultimo segmento. Specifica l'ampiezza della finestra di controllo di flusso. Pone un limite ai byte che possono essere inviati all'interlocutore, ed in caso sia zero, impedisce l'invio di ulteriori dati. 

Poiché i numeri di sequenza sono degli interi a 32 bit, hanno un limite superiore prima del quale si resettano. Si possono rappresentare come interi modulo $2^{32}$, quindi è possibile rappresentarli su una circonferenza, dividendola in vari spicchi per indicare quali sono 
attualmente utilizzati e per quale scopo. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img 
    \caption{Spazio dei \textit{Sequence Number} del Ricevente}%  
\end{figure}

Un primo spicchio coincide con i byte ricevuti e consumati dall'applicazione, parte dal numero scelto all'inizio della connessione. Il seguente spicchio contiene i dati ricevuti e riscontrati, ma non ancora consumati, fino al numero di sequenza corrente dell'applicazione. Il successivo spicchio contiene i dati ricevuti, contenuti nel \textit{buffer} non ancora riscontrati, quindi contengono numeri di sequenza maggiori del numero di sequenza attuale. In seguito lo spicchio si estende fino a coprire la dimensione del \textit{buffer} in ricezione, con un massimo di $2^{16}-1$ spazi disponibili. 
Questo \textit{buffer} contiene gli ultimi tre spicchi, mentre per il mittente contiene gli ultimi due, poiché i byte inviati e non ancora riscontrati non risultano nel \textit{buffer}, e si può basare solamente sui pacchetti precedenti per determinare la sua dimensione. Quindi questa dimensione è maggiore dello spazio attualmente disponibile nella macchina ricevente in un dato istante. Potenzialmente il mittente potrebbe inviare abbastanza byte da esaurire e fuoriuscire dalla dimensione del \textit{buffer}. Ma questo non considera la capacità del processo ricevente di consumare byte. 

Per rilasciare una connessione \textcolor{Bittersweet}{TCP}, uno dei due processi invia un segmento con il bit \verb|FIN| attivo, non avendo più dati da trasmettere. Quando questo processo riceve un riscontro, ritiene la sua connessione terminata. 
Ma i dati possono ancora fluire in verso opposto, vero questo processo che ha chiuso il suo flusso. La connessione si definisce rilasciata solamente quando entrambi i processi hanno rilasciato la connessione. Quando il secondo processo ha terminato i dati da trasmettere, invierà anch'esso un segmento \verb|FIN|, ed al suo riscontro terminerà la connessione. 
Sono quindi richiesti quattro segmenti per terminare una connessione \textcolor{Bittersweet}{TCP}, ma il primo pacchetto di riscontro, per il rilascio iniziato dal primo processo, può coincidere con il secondo pacchetto di rilascio, iniziato dal secondo processo. 

Per risolvere il problema dei due eserciti si aspetta un intervallo di tempo, \textit{timeout} definito come il doppio del \textcolor{LimeGreen}{ttl} stimato per un segmento. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img numerare le transizioni di stato per una sequenza \textit{client} o server e per le transizioni di stato 
    \caption{Diagramma di Transizione di Stato di una Connessione \textcolor{Bittersweet}{TCP}}%  
\end{figure}

In una connessione \textcolor{Bittersweet}{TCP} i due processi si definiscono \textit{client} e \textit{server}, generalmente il processo ad instaurare una connessione è il \textit{client} mentre il \textit{server} si rende disponibile. Il processo a terminare la connessione è il \textit{client}, anche se durante la connessione si era comportato come \textit{server}. 

Il processo \textit{client} per instaurare una nuova connessione si deve trovare nello stato \verb|closed|. Inviando un pacchetto \verb|syn| al \textit{server}, che si trova nello stato \verb|listen|, entra nello stato \verb|syn sent|. Il \textit{server} alla ricezione di questo segmento entra nello stato \verb|syn received| ed invia un riscontro. Quando questo viene ricevuto dal \textit{client} entra nello stato \verb|established| per segnalare che ha instaurato la connessione ed invia un riscontro al \textit{server}. Quando viene ricevuto dal \textit{server} anch'esso entra nello stato \verb|established|. 

In questo macro-stato corrisponde a molti più stati, come la corretta ricezione dei pacchetti, tramite riscontri e la gestione della finestra di controllo di flusso. 
In spedizione invece può corrispondere a stati di scelta della spedizione dei pacchetti, per massimizzare la banda e controllare la congestione della rete, e stati di spedizione di copie dei pacchetti in caso di mancato riscontro. 

\subsection{\textit{User Datagram Protocol}: \textcolor{Fuchsia}{UDP}}

Il protocollo \textcolor{Fuchsia}{UDP} fornisce ai livelli superiori un servizio di trasmissione non connesso e non affidabile. Non vengono infatti inviati riscontri di alcun tipo sull'esito della ricezione di pacchetti. 
Ma al compenso è molto veloce, si utilizza quando non è importante il riscontro dei pacchetti, preferendo l'efficienza, oppure se il riscontro viene gestito a livello applicativo. I pacchetti inviati con questo protocollo prendono il nome di datagrammi. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Struttura \textcolor{Fuchsia}{UDP} \textcolor{Brown}{pdu}}%  
\end{figure}

L'intestazione di un pacchetto \textcolor{Fuchsia}{UDP} viene diviso in quattro campi di 16 bit ciascuno. Questi specificano la porta del mittente e del destinatario, la lunghezza del datagramma ed il \textit{checksum}. Queste porte sono analoghe alle porte per il protocollo \textcolor{Bittersweet}{TCP}, e può utilizzare gli stessi protocolli di livello tre. 


\clearpage

\section{Livelli Applicativi: \textcolor{Mahogany}{DNS}, \textcolor{Peach}{HTML}, \textcolor{NavyBlue}{HTTP}}

\subsection{Il \textit{Domain Name System}: \textcolor{Mahogany}{DNS}}

Il \textcolor{Mahogany}{DNS} o Domain Name System è un applicazione del livello \textcolor{blue}{ISO-OSI} sopra al livello quattro. Dal livello quattro in poi le applicazioni possono essere programmate dall'utente e non è presente una divisione così netta tra i vari livelli applicativi. 

Poiché è scomodo utilizzare un numero per identificare un indirizzo, si vuole assegnare ad ogni interfaccia un nome, più riconoscibile, questo protocollo si occupa della mappatura 
tra questi nomi assegnati all'indirizzo \textcolor{Bittersweet}{IP} corrispondente. 
Agli albori dell'\textit{internet} questo ``Spazio dei Nomi'' o \textit{namespace} era \textit{flat}, ovvero l'insiemi dei nomi ammissibili non aveva restrizioni, quindi poteva essere assegnato qualsiasi nome arbitrario, e la mappatura veniva tracciata da una 
persona a mano su un \textit{file} testuale. Al crescere della dimensione della rete tuttavia potevano facilmente sorgere conflitti. La possibilità di aggiungere e modificare i nomi 
necessitava di un accesso a questo \textit{file} di testo centrale costante. 

Per migliorare questo servizio si è pensato di decentralizzare l'assegnazione dei nomi e la responsabilità del \textit{mapping} tra nome ed indirizzo. Inoltre la più 
importante aggiunta è la possibilità di accedere al \textit{mapping} con tecniche \textit{client}-\textit{server}. 

Si utilizza un \textit{database} distribuito per contenere queste corrispondenze, la robustezza e la resistenza di questo algoritmo sono favorite da meccanismi di \textit{caching} e replicazione di questo \textit{database}. 
Il \textit{namespace} viene partizionato per garantire un controllo efficiente non centralizzato delle assegnazioni. I nomi non sono più sequenze di caratteri, ma sequenze di 
caratteri separati da punti. 
I nomi che hanno un suffisso comune possono essere rappresentati attraverso un albero. 
Il livello più alto della gerarchia, l'autorità \textit{top level} delega la gestione dei nomi ad autorità assegnate a diverse partizioni dello spazio dei nomi. 
L'autorità \textit{top level} non si occupa delle partizioni interne, e si suppone tutti questi domini siano figli di un dominio radice, cui corrisponde una stringa vuota. 
Questa partizione può somigliare all'indirizzamento \textcolor{BurntOrange}{IPv4}, ma questo meccanismo di delega applicabile a più livelli può espandere lo spazio, mentre in \textcolor{BurntOrange}{IPv4} lo 
spazio è finito e definito a priori. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Gerarchia del \textit{Namespace}}%  
\end{figure}

Un dominio è un sottoalbero del \textit{namespace}, il cui nome è il nome della radice del sottoalbero. Le foglie di questo albero sono in corrispondenza di indirizzi \textcolor{BurntOrange}{IPv4} 
e \textcolor{OliveGreen}{IPv6}, e rappresentano interfacce. Inoltre è possibile che i nodi intermedi rappresentino ulteriori interfacce. Anche un singolo \textit{host} è un dominio. 
In questo momento esistono 1500 domini \textit{top level}, all'inizio questa distribuzione era molto ristretta. I domini nazionali sono stati standardizzati con sigle da ISO 3166, 
e recentemente questa restrizione è stata resa più lasca, ed esistono vari domini di recente definizione, come il dominio del \texttt{cern}. I domini su cui nasce \textit{internet} sono principalmente 
domini nord americani, come \texttt{com}, \texttt{edu}, \texttt{gov}, etc. 

L'organizzazione dei nomi di \textit{internet} viene chiamata \textit{Domain Name System}, i sistemi che realizzano il \textit{mapping} tra indirizzi e nomi sono chiamati 
\textit{Name Server} (\textcolor{Lavender}{ns}). Alcuni hanno la delega per una porzione del \textit{namespace}, e questi sono in grado di dialogare tra di loro. Un \textcolor{Lavender}{ns} ha informazioni complete su una parte 
del \textit{namespace}, detta zona, sulla quale ha autorità. Una zona è un sottoalbero del \textit{namespace}, eventualmente privato di alcuni sottoalberi. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Zona del \textit{Namespace}}%  
\end{figure}

Questi sottoalberi su cui non ha autorità sono altri domini delegati ad altri \textcolor{Lavender}{ns} dal \textit{top level}. Un \textcolor{Lavender}{ns} può essere autorità di varie zone, inoltre per la stessa zona 
possono essere associati più \textcolor{Lavender}{ns} autorità, per motivi di resistenza ai guasti. Poiché questo sistema è nevralgico per la gestione di \textit{internet}, ed è necessario il suo 
funzionamento per l'accesso alla rete.  

I \textcolor{Lavender}{ns} possono essere primari o secondari, i \textit{server} primari contengono le informazioni aggiornate sul \textit{mapping} della zona, mentre i \textcolor{Lavender}{ns} secondari richiedono periodicamente 
il \textit{mapping} della zona al \textit{server} primario. Si lavora su modiche o assegnazioni dei nomi solamente sul \textcolor{Lavender}{ns} primario. 
Un \textcolor{Lavender}{ns} può essere contemporaneamente primario per certe zone e secondario per altre. Si hanno vari gradi di libertà sul numero dei \textcolor{Lavender}{ns}, sulla possibilità di essere 
primari o secondari, oppure sulla loro posizione, possono essere anche lontani dalle macchine delle quali conservano i nomi. 

\subsubsection{Risoluzione}

I \textit{client} che usano i \textcolor{Lavender}{ns} si chiamano \textit{resolver} e sono all'interno delle macchine \textit{host}. Hanno la capacità di interrogare i \textcolor{Lavender}{ns} ed interpretare le loro risposte. Sopratutto 
sono in grado di inviare le informazioni ricavate ai programmi che li utilizzano. 
Non necessariamente è un processo autonomo, i \textit{resolver} si possono trovare all'interno di comuni librerie contenute in alcuni \textit{browser}. Il \textit{resolver} dato un nome assegnato ad un certo indirizzo ne restituisce l'indirizzo \textcolor{Bittersweet}{IP}.

Se il \textit{resolver} ha già le informazioni necessarie le fornisce al \textit{client}, altrimenti le chiede direttamente alla radice autorità dello spazio dei nomi, la quale 
fornisce al \textit{resolver} un \textcolor{Lavender}{ns} più specifico, scendendo l'albero fino a raggiungere l'indirizzo specifico. Questi \textcolor{Lavender}{ns} assegnati alla radice sono costantemente 
sotto pressione, poiché l'intera rete si basa interamente su di loro per effettuare il processo di risoluzione. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Processo di Risoluzione}%  
\end{figure}

Per la risoluzione sono possibili vari atteggiamenti, può essere ricorsiva oppure iterativa, anche se una risoluzione solamente iterativa non viene mai utilizzata sulla rete. Nella risoluzione ricorsiva il \textit{client} chiede al \textit{server} una risorsa, 
e pretende come risultato l'indirizzo, se il \textit{server} non la conosce, è suo compito contattare altri \textit{server} per ottenerla. Mentre nella risoluzione iterativa, è il \textit{client} a dover 
contattare ulteriori \textit{server}, specificati dal \textit{server} iniziale. Nella risoluzione iterativa i \textit{server} non devono memorizzare lo stato della rete, quindi è un approccio più efficiente per i \textit{server}. 
Questo processo risolutivo può essere completamente iterativo o ricorsivo, oppure sono possibili atteggiamenti misti, dove il \textit{resolver} effettua una \textit{query} ricorsiva al \textcolor{Lavender}{ns} e questo effettua delle \textit{query} iterative a vari \textcolor{Lavender}{ns}, appunto per rendere più efficiente questo processo. Questo corrisponde a quanto descritto nell'immagine precedente. 


Le informazioni memorizzate tra le vari \textit{query} vengono salvate su diverse \textit{cache} dentro i \textcolor{Lavender}{ns}, che svolgono il ruolo di autorità per le varie zone, quindi in alcuni casi 
non è necessario scendere l'intera gerarchia della zona, la \textit{cache} è presente anche al livello di applicazione, come i \textit{browser} quindi può essere non necessario utilizzare il processo \textit{resolver}. 
Alcuni \textit{server} possono memorizzare informazioni negative, quindi si suppone l'informazione sulla \textit{cache} scade dopo un certo intervallo di tempo. Il tempo di vita delle informazioni in \textit{cache} si chiama \textcolor{LimeGreen}{ttl}, \textit{Time To Live} e viene scelto con 
opportune metriche per un compromesso tra consistenza ed efficienza, non è in relazione con il \textcolor{LimeGreen}{ttl} dei pacchetti sulla rete. 

Alcuni \textcolor{Lavender}{ns} non sono autorità per nessuna zona, e sono solamente a disposizione dei \textit{client} per accettare \textit{query} ricorsive ed effettuare \textit{query} iterative ad altri \textcolor{Lavender}{ns}. 
Non sono solo a disposizione dei \textit{client}. Normalmente ogni \textcolor{teal}{ISP} ne mette a disposizione uno per i propri clienti, sono chiamati a volte \textit{Local} \textcolor{Lavender}{ns}, o \textit{Caching} \textcolor{Lavender}{ns}, oppure 
\textit{Recursive} \textcolor{Lavender}{ns}. 

Le informazioni \textcolor{Mahogany}{DNS} sono memorizzate su \textit{Resource Record}, ed ogni dominio è associato ad uno o più \textit{Resource Record}, questi contengono gli indirizzi \textcolor{Bittersweet}{IP}, ma anche 
altre informazioni che permettono di associare ai nomi altri servizi. Uno di questi servizi sono i servizi di posta elettronica. Hanno la seguente struttura:
\begin{minted}{html}
    <resource record>
        <domain name><time to live>
        <class><type><value>
\end{minted}
Questi \textit{record} contengono campi per il nome del dominio, il \textcolor{LimeGreen}{ttl}, la classe, in \textit{internet} è sempre \texttt{IN}, il tipo di \textit{record} ed il valore, che dipende dal tipo. I tipi principali sono 
\begin{itemize}
    \item \texttt{SOA}: \textit{Start of Authority}, contiene informazioni amministrative della zona;
    \item \texttt{A}: Contiene nel valore l'indirizzo \textcolor{BurntOrange}{IPv4} dell'\textit{host};
    \item \texttt{MX}: Specifica il nome dell'\textit{host} che accetta le \textit{mail} indirizzate al dominio del \textit{record};
    \item \texttt{NS}: Il \textcolor{Lavender}{ns} per una zona;
    \item \texttt{AAAA}: Contiene nel valore l'indirizzo \textcolor{OliveGreen}{IPv6} dell'\textit{host};
    \item \texttt{CNAME}: \textit{Canonical Name}, il nome del dominio specificato corrisponde ad un altro nome. 
\end{itemize}

Si possono assegnare dei nomi alle macchine che si comportano come \textcolor{Lavender}{ns}. 
Le radici contengono \textit{record} che indicano i \textcolor{Lavender}{ns} assegnati alle varie zone, e per permettere la risoluzione contengono anche un \textit{record} di tipo \texttt{A} (o \texttt{AAAA}) con il loro indirizzo. Essendo \textit{record} contenenti indirizzi di una zona dovrebbero trovarsi nel \textcolor{Lavender}{ns} relativo a quella zona, quindi questa può essere considerata un'invasione di gerarchia da parte della radice. Questi \textit{record} prendono il nome di \textit{Glue Record}. 

I messaggi \textcolor{Mahogany}{DNS} si realizzano in due tipi di stesso formato, richiesta e risposta. Tra i campi dell'\textit{header} si hanno:
\begin{itemize}
    \item \texttt{QR}: \textit{Query}, indica se il messaggio è una domanda o una risposta;
    \item \texttt{RD}: \textit{Recursion Required}, indica che la query è di tipo ricorsivo.
\end{itemize}
Tra i campi della \textit{question section} si hanno:
\begin{itemize}
    \item \texttt{NAME}: Nome della risorsa;
    \item \texttt{TYPE}: Tipo della risorsa.
\end{itemize}


Questi messaggi devono viaggiare su un protocollo di livello quattro affidabile, quindi sembra bisogna essere assegnato al protocollo \textcolor{Bittersweet}{TCP}, ma in realtà viene assegnato ad \textcolor{Fuchsia}{UDP}. 
\`{E} la logica applicativa del \textit{resolver} che si prende carico del meccanismo dei riconto, infatti in caso le richieste non ricevono risposta, questo invia nuovamente la richiesta dopo un certo intervallo di tempo. 
I \textit{client} si rivolgono alla porta \textcolor{Fuchsia}{UDP} \texttt{53} \textit{Well Known}, la richiesta e la risposta viaggiano entrambe su singoli pacchetti \textcolor{Fuchsia}{UDP}. 
Per dialoghi che richiedono risposte di grande dimensioni si può usare \textcolor{Bittersweet}{TCP}, nel caso in cui \textit{server} secondario si rivolge al primario per richiedere le informazioni aggiornate. 

Sotto il \textcolor{Mahogany}{DNS} non ci sono solo messaggi \textcolor{Fuchsia}{UDP}, ma ci sono protocolli di sicurezza per evitare vengano letti da terze parti, la risposta viene quindi considerata 
autentica. Questi meccanismi non sono trattati in questo corso. 

Il comando \verb|dig| permette di effettuare il processo di risoluzione comportandosi come un \textit{client} ed osservare a schermo le risposte ottenute. Prende come argomento il nome o indirizzo \textcolor{Bittersweet}{IP} del \textcolor{Lavender}{ns} a cui si possono aggiungere parametri opzionali come il nome della risorsa che si vuole accedere, il tipo di \textit{query} che si vuole effettuare, la porta a cui si vuole effettuare questa richiesta, etc. Su Windows si può usare il comando analogo \verb|nslookup|. 

Il comando restituisce la lista dei \textit{record} ottenuti come risposta ed il loro tipo: 
\begin{minted}{powershell}
    \prompt> dig google.com
    ; <<>> DiG 9.18.28-0ubuntu0.24.04.1-Ubuntu <<>> google.com
    ;; global options: +cmd
    ;; Got answer:
    ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 40999
    ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

    ;; QUESTION SECTION:
    ;google.com.                    IN      A

    ;; ANSWER SECTION:
    google.com.             103     IN      A       142.251.209.14

    ;; Query time: 10 msec
    ;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP)
    ;; WHEN: Wed Jan 15 12:36:21 UTC 2025
    ;; MSG SIZE  rcvd: 54
\end{minted}

I nomi vengono rappresentati con un punto alla fine per convenzione per indicare che sono sottoalberi di una radice comune avente stringa vuota. 
Il \textit{server} di risposta coincide all'interfaccia di lo, dato che questo \textit{record} era già presente nella \textit{cache} del \textit{resolver}. 
Se viene eseguito il comando dopo un certo periodo di tempo il \textcolor{LimeGreen}{ttl} restituito è minore, dato che decrementa al passare del tempo per diminuire la validità nella \textit{cache}. 
Se viene effettuata questa ricerca su una machina locale, viene restituito un \textit{record} contenente il suo \textit{alias}, seguito dai \textit{record} che utilizzano questo nome per identificare l'indirizzo. Si utilizzano questi \textit{alias} poiché il nome del servizio deve esistere per fornire informazioni agli utenti, viene realizzato a scopo di \textit{marketing}, nella fase di risoluzione infatti viene connesso al nome effettivo di quel servizio. 

Per effettuare una \textit{query} non ricorsiva si utilizza la \textit{flag} \verb|+norecurse|, restituisce molti nomi dei \textcolor{Lavender}{ns} e relativi indirizzi. Inoltre con \verb|+trace| è possibile seguire il cammino delle deleghe che viene effettuato per individuare l'indirizzo, fornendo i \textit{record} analizzati da ogni \textcolor{Lavender}{ns} nella sequenza per individuare l'indirizzo. I primi \textcolor{Lavender}{ns} in questa lista rappresentano le radici, \verb|root-servers|, di varie zone, identificati da una lettera come prefisso per indicare il gestore. I \verb|root-servers| europei hanno tradizionalmente il prefisso \verb|k|. 

\subsection{Il Linguaggio \textcolor{Peach}{HTML}}

Il linguaggio \textcolor{Peach}{HTML} è il linguaggio che specifica le pagine web, si interessa il protocollo che porta queste informazioni attraverso la rete, ovvero \textcolor{NavyBlue}{HTTP}. 
\textcolor{Peach}{HTML}, \textit{HyperText Markup Language}, è un testo che può contenere riferimenti ad altri ipertesti. Un marcatore è un codice che segnala l'inizio o la fine di una primitiva di 
formattazione del testo. 

Le caratteristiche dell'ipertesto sono la concisione, dato che il contenuto di una singola pagina può essere ristretto all'essenziale; la completezza, l'informazione distribuita sulle varie pagine può essere arbitrariamente dettagliata; la condivisione, i dati non vengono replicati ma condivisi, evitando quindi le ridondanze. 
Si può arrivare a livelli di completezza arbitrari affidando a subordinate distribuendo l'informazione nelle pagine. 
L'ipertesto costituito dall'insieme di tutte le pagine presenti su \textit{internet} viene denominato \textit{World Wide Web}, rete estesa al mondo intero. 
Bisogna distinguere tra \textit{internet} e WWW. La parola \textit{internet} è ulteriormente ambigua poiché il nome del protocollo di livello quattro \textit{Internet Protocol} e l'insieme dei protocolli di rete \textit{Internet Protocol Suite} condividono lo stesso nome. 
Inoltre si riferisce alla struttura fisica, ma spesso si riferisce a tutti i servizi disponibili in questo ambiente distribuito. 
Mentre WWW si riferisce alla rete logica costituita dalle pagine \textit{web} e dai loro \textit{hyperlink}, queste costituiscono solo uno dei servizi offerti da \textit{internet}. 


\textcolor{Peach}{HTML} è un linguaggio di \textit{markup}, è un linguaggio che codifica delle informazioni tramite marcatori. Un linguaggio di marcatura ha senso quando si vuole rappresentare 
un'informazione che può essere strutturata in termini sequenziali. 

Si possono identificare linguaggi di marcatura fisica o logica. I linguaggi di marcatura fisica descrivono dettagliatamente come apparirà il testo formattato. 
Queste hanno una filosofia WYSIWYG, \textit{What You See Is What You Get}. Si vuole poter descrivere testi per schermi di dimensione e risoluzioni differenti, quindi specificare direttamente la dimensione degli oggetti di una pagina è sconsigliato. Si utilizzano quindi linguaggi di marcatura logica o semantica descrive il significato strutturale degli oggetti da formattare con una filosofia WYGIWYM, \textit{What You Get Is What You Mean}. 

\textcolor{Peach}{HTML} usa una marcatura logica e permette di realizzare pagine \textit{web} senza doversi preoccupare delle caratteristiche del dispositivo sul quale quel testo sarà offerto in 
consultazione. 
Ogni marcatore in \textcolor{Peach}{HTML} viene identificato all'interno di parentesi acute \verb|< ... >|. I marcatori di fine formattazione hanno uno \textit{slash} prima della parentesi angolata 
aperta \verb|</ ... >|. Alcuni marcatori ammettono valori, specificati dopo un uguale: \verb|<marcatore attributo1 = valore1 ... attributoN = valoreN>|. 
I commenti si scrivono nel seguente formato \verb|<!-- ... --->|.
Le parentesi angolate non sono quindi disponibili come caratteri si utilizzano caratteri speciali per indicare questi caratteri che non possono essere scritti 
direttamente. Iniziano con \verb|&| o \verb|;|:
\begin{itemize}
    \item \verb|&lt|: \verb|<|;
    \item \verb|&gt|: \verb|>|;
    \item \verb|&amp|: \verb|&|;
    \item \verb|&_grave|: lettera \verb|_| con accento grave. 
\end{itemize} 

Esistono marcatori di metadati che non necessariamente servono per la formattazione, ma possono inserire marcatori per identificare certe parole all'interno della pagina: \verb|<meta ...>|. 

Un \textit{file} \textcolor{Peach}{HTML} viene strutturato all'interno del marcatore \verb|<html> ... </html>| e si può dividere in due sezioni \verb|<head> ... </head>| che contiene informazioni relative all'intera pagina, 
e \verb|<body> ... </body>| che contiene descrizioni relative agli oggetti da visualizzare nella pagina. 
Nell'intestazione si può trovare il titolo con \verb|<title> ... </title>|, metadati \verb|<meta ... = ... >|

Si può formattare il testo con i seguenti marcatori:
\begin{itemize}
    \item \verb|<center> ... </center>|: Centratura;
    \item \verb|<h1> ... </h1>|: Titolo;
    \item \verb|<h2> ... </h2>|: Sottotitolo;
    \item \verb|<b> ... </b>|: \textbf{Bold};
    \item \verb|<i> ... </i>|: \textit{Italic};
    \item \verb|<u> ... </u>|: \underline{Sottolineato};
    \item \verb|<blink> ... </blink>|: Lampeggiante. 
\end{itemize}


Si definiscono ancore con il marcatore \verb|<a href="..."> ... </a>|, in base all'attributo si possono creare \textit{hyperlink} specificando un \textcolor{SpringGreen}{URL}, oppure un punto di arrivo o un indirizzo ad un punto di arrivo a questa o ad altre pagine. 

Si possono inserire immagini con \verb|<img src="\textcolor{SpringGreen}{URL}">|, a capi di un paragrafo \verb|<p>| o \textit{break} \verb|<br>|, linee orizzontali \verb|<hr>| di cui si può modificare 
lo spessore con \verb|size=...|. Si può cambiare il colore del font con \verb|<font color=...></font>|. 
Si possono realizzare liste non ordinate:
\begin{minted}{html}
    <ul>
        <li> ...
        <li> ...
    </ul>
\end{minted}
Oppure ordinate:
\begin{minted}{html}
    <ol>
        <li> ...
        <li> ...
    </ol>
\end{minted}
Si possono definire tabelle con:
\begin{minted}{html}
    <table border=...>
        <th> ... </th> <!-- titolo cella-->
        <tr>  <!-- inizio-fine linea-->
            <td> ... </td> <!-- inizio-fine cella-->
            ...
            <td> ... </td> <!-- inizio-fine cella-->
        </tr> 
    </table>
\end{minted}

Si possono definire ulteriori marcatori ed estensioni, ma se il \textit{browser} non conosce il marcatore non produce errore, ma semplicemente lo ignora. 
\textcolor{Peach}{HTML} è un linguaggio estremamente basilare che si è evoluto nel tempo, attualmente siamo alla versione \textcolor{Peach}{HTML} 5. 
Il codice \textcolor{Peach}{HTML} viene scandito riga per riga, partendo dall'alto ed eventualmente viene formattata la pagina. \textcolor{Peach}{HTML} viene spesso accompagnato da altre tecnologie come 
javascript o CSS, \textit{Cascading Style Sheets}, fogli di stile, elementi di formattazione che possono essere utilizzati per rendere la pagina al meglio. 

\subsection{\textcolor{SpringGreen}{URL} ed il Protocollo \textcolor{NavyBlue}{HTTP}}

Prima di descrivere il protocollo \textcolor{NavyBlue}{HTTP}, bisogna descrivere l'\textcolor{SpringGreen}{URL}, \textit{Uniform Resource Locator}, o l'URI, \textit{Uniform Resource Identifier}. Poiché in \textit{internet} non si differenzia tra la risorsa e la sua posizione. 

Un \textcolor{SpringGreen}{URL} è una rappresentazione testuale e compatta di una risorsa disponibile, in modo sintetico realizzata da uno schema, ed una parte dipendente dallo schema, separati da \verb|:|. 
Lo schema descrive il tipo di risorsa acceduta, e la parte seguente la individua secondo le caratteristiche di un dato schema. Tipicamente lo schema è \verb|http| o \verb|https|, 
questi sono sia risorse che protocolli per acquisire risorse. Schemi come \verb|\textit{file}| sono risorse presenti sul proprio calcolatore. 

Alcuni schemi utilizzano la stessa sintassi per la parte dipendente, questa sintassi si chiama \textit{Common Internet Scheme Syntax}, CISS. Si utilizza un doppio \textit{slash} iniziale 
seguito da un campo con l'\textit{userid} e la \textit{password} seguita da una chiocciola, ma questo è molto raramente utilizzato negli \textcolor{SpringGreen}{URL} moderni. 
Il secondo campo dopo la chiocciola corrisponde all'indirizzo dell'\textit{host}, il suo numero \textcolor{Bittersweet}{IP}, o ad una stringa identificativa di questo indirizzo sulla rete. 
Il campo successivo specificato dopo \verb|:| indica la porta dove è disponibile quella risorsa, si suppone la risorsa sia un livello quattro che dispone di porte, 
questa può essere omessa, ed in caso si utilizza una porta di quelle note, associate a protocolli \textcolor{NavyBlue}{HTTP}, come la porta \texttt{80}. L'ultimo campo individua un \textit{file} 
all'interno del \textit{filesystem}, del \textit{server} con \verb|/| seguito dall'indirizzo del \textit{file}. Alcuni sistemi presentano variazioni nella sintassi di questo campo, come \textcolor{NavyBlue}{HTTP} e 
HTTPS. 
Questo identifica una risorsa, tipicamente attraverso l'indirizzo dell'\textit{host}, ma l'indirizzo \textcolor{Bittersweet}{IP} ha anche il ruolo di locazione, quindi è possibile localizzare la 
risorsa dato l'\textcolor{Bittersweet}{IP}. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Struttura Schema di \textcolor{NavyBlue}{HTTP}}%  
\end{figure}

Quando un browser deve accedere ad una risorsa individuata da un \textcolor{SpringGreen}{URL} etra i campi di indirizzi e la porta, se non è specificata utilizza la porta \texttt{80}, per il protocollo 
\textcolor{NavyBlue}{HTTP}. Questo lavoro lo effettua qualsiasi applicazione che tenta di accedere ad una risorsa. 
Il campo \textit{userid} e \textit{password} vengono utilizzati per gestire un colloquio con il \textit{server}, senza coinvolgere l'utente. In coda al percorso della risorsa può esserci una stringa preceduta dal 
carattere \verb|#| per individuare la posizione all'interno della pagina \textcolor{Peach}{HTML}, utilizzata dal \textit{client} e non inviata al \textit{server}. 
Oppure una stringa preceduta da \verb|?| viene inviata al \textit{server}, per specificare parametri o altre opzioni. 

Il protocollo \textcolor{NavyBlue}{HTTP}, \textit{HyperText Transfer Protocol}, è stato progettato come un protocollo di livello applicativo per realizzare sistemi distribuiti, basati su 
ipertesti, anche se da molto non è più esclusivo per \textcolor{Peach}{HTML}. Questo protocollo si basa su uno schema richiesta-risposta tra il \textit{client} ed il \textit{server}; uno di questi colloqui tra \textit{client} e \textit{server} si chiama sessione. 

\textcolor{NavyBlue}{HTTP} venne inventato da Tim Bernes-Lee, un ricercatore del CERN nel 1989, e da \textcolor{NavyBlue}{HTTP}/3, nel progetto QUIC, c'è una variazione molto grande rispetto alle reti 
precedenti, con lo standard RFC 9114. 


Una sessione di \textcolor{NavyBlue}{HTTP}/1.0 è composta da quattro fasi: apertura, richiesta, risposta e chiusura. Nel codice del \textit{server} è stato specificato ad un processo di ascoltare 
sulla porta \texttt{80}, oppure una porta specificata per ascoltare eventuali richieste di connessione. Un cliente quindi puà effettuare una connessione \textcolor{Bittersweet}{TCP} con questa 
porta \textcolor{Bittersweet}{TCP} del \textit{server}. Una volta instaurata una connessione \textcolor{Bittersweet}{TCP} viene inviata una richiesta al \textit{server}, un pacchetto \textcolor{NavyBlue}{HTTP} di richiesta al \textit{server} con la specifica della 
risorsa alla quale si vuole accedere. Il \textit{server} poi restituisce la risorsa, tipicamente un \textit{file}, contenente una descrizione \textcolor{Peach}{HTML} di una pagina che si vuole visualizzare. 
Dopo aver terminato la trasmissione, il \textit{server} chiude la connessione \textcolor{Bittersweet}{TCP}. 
Avviene quindi un singolo scambio \textit{client}-\textit{server} in ogni sessione, questa sezione è completamente \textit{stateless}. 

Nella richiesta viene specificato uno di possibili metodi tra questi seguenti, per specificare quale azione da eseguire alla risorsa:
\begin{itemize}
    \item \verb|GET|: Richiede la risorsa indicata;
    \item \verb|POST|: Invia dati alla risorsa indicata;
    \item \verb|HEAD|: Chiede informazioni sulla risorsa indicata;
    \item \verb|PUT|: Copia dei dati inviati sulla risorsa con una sostituzione di \textit{file};
    \item \verb|DELETE|: Richiede la cancellazione della risorsa:
    \item \verb|OPTIONS|: RIchiede di conoscere le opzioni disponibili per il trasferimento della risorsa specificata. 
\end{itemize}


Un pacchetto \textcolor{NavyBlue}{HTTP} di richiesta è strutturato da un'intestazione composta da uno di questi metodi, la risorsa e la versione di protocollo da adottare 
seguita da informazioni aggiuntive, \textit{request fields}, sul collegamento instaurato. Una riga vuota quindi divide l'intestazione dal corpo del pacchetto dove sono presenti i dati effettivamente inviati dal \textit{client} al \textit{server}. 

\begin{figure}[H]%
    \centering%
    \includegraphics[width=3cm]{example-image}% %% TODO img
    \caption{Struttura \textcolor{NavyBlue}{HTTP} \textcolor{Brown}{pdu} di Richiesta}%  
\end{figure}

I pacchetti di risposta hanno nell'intestazione la versione, il codice di stato ed in linguaggio naturale la spiegazione per 
il codice. 
Questi codici di stato possono essere positivi, di tipo \verb|2xx| o \verb|3xx| oppure negativi \verb|4xx| o \verb|5xx|. Non è necessario conoscere questi codici di 
risposta poiché nel pacchetto è presente loro spiegazione. 
I codici di risposta sono tipicamente sempre leggibili, per molti protocolli che definiti da standard RFC. 
Nell'intestazione sono presenti anche i \textit{response fields} su trasferimento dal \textit{server} al \textit{client}, seguiti da una riga vuota per separare l'intestazione dal corpo del pacchetto, contenente i dati inviati. 

I codici di stato più comuni sono, riguardo a richieste soddisfatte del \textit{client}:
\begin{itemize}
    \item \verb|200|: Il pacchetto contiene ciò che è stato richiesto;
    \item \verb|201|: \`{E} stat creata una nuova risorsa come richiesto;
    \item \verb|202|: \`{E} stata accettata la richiesta, ma non è stata creata la nuova risorsa. 
\end{itemize}
Possono essere riguardo ulteriori azioni richieste per completare l'operazione:
\begin{itemize}
    \item \verb|301|: La risorsa è disponibile ad un altro indirizzo;
    \item \verb|304|: La risorsa non è stata modificata. 
\end{itemize}
Possono specificare che la richiesta errata e non può essere soddisfatta:
\begin{itemize}
    \item \verb|400|: La sintassi della richiesta è errata;
    \item \verb|401|: \`{E} richiesta autorizzazione;
    \item \verb|403|: La risorsa non è disponibile;
    \item \verb|404|: La risorsa non esiste;
    \item \verb|405|: Il metodo specificato non è permesso per la risorsa indicata;
    \item \verb|414|: Il nome della risorsa è troppo lungo. 
\end{itemize}
Oppure possono indicare che non può essere soddisfatta una richiesta legittima:
\begin{itemize}
    \item \verb|500|: \`{E} stato sollevato un errore interno al \textit{server};
    \item \verb|501|: La funzionalità richiesta non è implementata;
    \item \verb|505|: La versione del protocollo specificata non è supportata. 
\end{itemize}


Nelle versioni successive i pacchetti vengono inviati allo stesso modo, ciò che ca,bia sono le informazioni addizionali. 
Possono essere presenti alcuni campi di richiesta:
\begin{itemize}
    \item \verb|accept-charset|: Insieme di caratteri accettabili;
    \item \verb|cookie|: Un \textit{cookie} inviato precedentemente dal \textit{server}, usando \verb|set-cookie|;
    \item \verb|content-length|: Lunghezza in byte del corpo;
    \item \verb|host|: Il \textit{domain name} del \textit{server} e il numero di \textit{port} \textcolor{Bittersweet}{TCP}, utile per servire vari domini sullo stesso \textit{server}. Su uno stesso \textit{server} possono essere presenti servizi diversi, si utilizza il campo \verb|host| per specificare a quale di questi si vole accedere;
    \item \verb|if-modified-since|: Permette al \textit{server} di inviare una risposta \verb|304| \textit{not modified} se la risorsa è invariata dopo la data specificata; 
    \item \verb|if-none-match|: Permette al \textit{server} di inviare una risposta \verb|304| \textit{not modified} se la risorsa è invariata. 
\end{itemize}
Alcuni campi di risposta sono:
\begin{itemize}
    \item \verb|ETag|: Un identificatore assegnato da un \textit{server} ad una specifica versione della risorsa, può essere ottenuto con una funzione di \textit{has};
    \item \verb|set-cookie|: Un \textit{cookie} \textcolor{NavyBlue}{HTTP}. 
\end{itemize}
Il \textit{server} può 
offrire informazioni aggiuntive rispetto ad un semplice valore temporale. 
Un \textit{cookie} è un dato spedito dal \textit{server} e memorizzato nel \textit{client}, viene re-inviato dal \textit{client} al \textit{server} ogni volta che accede a certe risorse, definite dallo scope del \textit{cookie}. 
Viene usato per gestire uno stato nelle sessioni \textcolor{NavyBlue}{HTTP}. Il \textit{server} può quindi riconoscere attività precedenti dello stesso \textit{client} in base ai \textit{cookie}. 
L'applicazione più evidente è quella dell'autenticazione degli accessi ad un \textit{server}, questo \textit{cookie} permettere al \textit{server} di identificare lo stesso \textit{client}, quindi attribuisce 
i diritti per poter eseguire le operazioni successive. 
Può anche permettere di tracciare le pagine visitate da uno stesso utente. Un \textit{cookie} può essere utilizzato anche da altri servizi nonostante non sia stato rilasciato per 
un certo sito. Nell'EU all'accesso di un sito, questo è obbligato di specificare il motivo dei \textit{cookie} che vengono utilizzati, il loro scopo o finalità, ed il modo in cui 
vengono salvati e mantenuti nel tempo. Inoltre è possibile accedere comunque ad un sito senza accettare all'utilizzo dei \textit{cookie}. 


Il protocollo \textcolor{NavyBlue}{HTTP} 1.1 permette di effettuare diverse sessioni sulla stessa 
connessione \textcolor{Bittersweet}{TCP}, ma questo dipende comunque dal \textit{server}, diminuendo la latenza. 

Questa possibilità è particolarmente importante se insieme a \textcolor{NavyBlue}{HTTP} e \textcolor{Bittersweet}{TCP} si 
utilizza un protocollo per rendere sicure le connessioni. Attualmente si utilizza il 
protocollo TLS, \textit{Transport Layer Security}, dopo l'instaurazione della 
connessione \textcolor{Bittersweet}{TCP} i due \textit{host} si scambiano informazioni per mantenere la sicurezza delle connessioni con un altro \textit{three-way-handshake}. Quindi all'instaurazione della connessione \textcolor{Bittersweet}{TCP} si effettua uno 
scambio per determinare il protocollo di sicurezza utilizzato. Questo permette di offuscare i pacchetti trasmessi tra queste due macchine mantenendo la connessione 
persistente. 
Se fosse possibile effettuare una singola connessione \textcolor{Bittersweet}{TCP} per ogni richiesta verrebbero scambiati 7 pacchetti di apertura-chiusura per una singola sessione, 10 considerando anche i protocolli di sicurezza. Quindi in versioni precedenti alla 1.1 l'\textit{overhead} per l'invio di un singolo pacchetto è molto rilevante.   

\textcolor{NavyBlue}{HTTP} quindi rappresenta una sequenza di transizioni richiesta-risposta tra un \textit{client} ed un \textit{server}, tipicamente originate da un singolo utente, per accedere a risorse tra loro correlate. 

Se si usano \textcolor{NavyBlue}{HTTP} e TLS separatamente, è opzionale l'utilizzo di TLS, mentre il protocollo HTTPS presenta l'utilizzo obbligatorio del protocollo di sicurezza TLS. Cambia anche la porta di ascolto nota e diventa la porta \texttt{443}. 

Nonostante la possibilità di inviare più richieste su una stessa connessione, queste vengono effettuate sequenzialmente, e quindi una nuova richiesta può essere inviata solamente dopo aver ricevuto la risposta della precedente, indipendentemente dal tempo di attesa. Per cui dalla seconda versione del protocollo si inseriscono meccanismi di parallelismo, inviando varie richieste sulla stessa connessione, in un processo chiamato \textcolor{NavyBlue}{HTTP} \textit{pipelining}. 

\textcolor{NavyBlue}{HTTP}/3 invece utilizza un ulteriore protocollo di trasporto chiamato QUIC e non \textcolor{Bittersweet}{TCP}. QUIC utilizza pacchetti \textcolor{Fuchsia}{UDP}, basato su implementazioni nell'\textit{user-space} e quindi 
non sono legate all'aggiornamento del sistema operativo. 
Si intreccia quindi l'evoluzione dei protocolli di trasporto e l'evoluzione di \textcolor{NavyBlue}{HTTP}. 
Questo rappresenta un fenomeno di evoluzione molto recente. 

In QUIC il \textit{three-way-handshake} è mescolato con l'\textit{handshake} del protocollo TLS 1.3, con un minore \textit{overhead} della connessione. Per utilizzare questo protocollo, 
anche il \textit{server} deve poterlo utilizzare, sicuramente supportato da \textit{server} appartenenti a Google, avendo creato questo protocollo. Anche se il 
\textit{server} non appartiene a Google, allora è possibile che utilizzi il protocollo QUIC, circa il 20\% dei siti \textit{web} infatti utilizza il protocollo \textcolor{NavyBlue}{HTTP}/3, mentre tutti i 
\textit{browser} lo utilizzano, perché vogliono offrire sempre migliori prestazioni ai loro utenti. 

\clearpage

\section{Posta Elettronica}

La descrizione di questo servizio web consiste nel definire un criterio per la sua progettazione, utilizzato per realizzare nuovi servizi o modificarne di esistenti. 
La progettazione è divisa in quattro fasi, un'analisi dei requisiti, definendo le caratteristiche dei servizi. La specifica delle primitive del servizio, che rappresenta la sua interfaccia. 
Definizione dell'architettura e delle operazioni, e la definizione dei protocolli per ogni tipo di comunicazione, bisogna definire la struttura delle PDU, degli stati e delle procedure del protocollo. 

I servizi di posta elettronica possono essere forniti da \textcolor{teal}{ISP}, aziende come Google, che offrono altri servizi web. 


Si effettua in seguito un'analisi dei requisiti di progettazione per un servizio di posta elettronica. 
Un servizio di posta deve poter gestire messaggi in partenza ed in arrivo, spedire e ricevere messaggi ad uno o più 
destinatari. Richiede ri preservare la riservatezza dei dati, e si vuole avere una certezza sulla consegna, è anche possibile avere una consegna 
differita nel tempo, per garantire la consegna. Quest'approccio duale rispetto ad altri servizi web. 
Si vuole che la configurazione sia poco onerosa da parte degli utenti finali con un'interfaccia utente 
elementare ed intuitiva. 


Definiti i requisiti si definiscono delle primitive di servizio offerte agli utenti, per i messaggi in partenza:
\begin{itemize}
    \item Composizione di un messaggio;
    \item Memorizzazione di un messaggio;
    \item Cancellazione di un messaggio;
    \item Caricamento di un messaggio. 
\end{itemize}
Per i messaggi ricevuti:
\begin{itemize}
    \item Lettura dei messaggi;
    \item Memorizzazione di un messaggio;
    \item Cancellazione del messaggio;
    \item Stampa di un messaggio. 
\end{itemize}



Queste sono le primitive di base per poter almeno gestire la posta elettronica. 
Per progettare un servizio bisogna effettuare un'analisi dei requisiti e definire su di questi una serie di primitive di servizio. Dopo queste due fasi bisogna 
definire l'architettura del servizio. 


Si considera l'architettura odierna della posta elettronica, descrivendo ulteriori architetture non realizzabili valutando variazioni. Si considera un possibile architettura realizzata da una connessione diretta tra il mittente ed il destinatario. Sono quindi presenti due processi su questi due \textit{host}, attivi, che devono poter ascoltare e inviare dati su una connessione, potrebbero utilizzare \textcolor{Bittersweet}{TCP}. Per definire la porta di ascolto si potrebbe definire uno standard globale, su una porta ben nota alla definizione dell'architettura. 
Questo approccio è molto semplice, il messaggio viene recapitato in tempo reale e si ha anche la certezza della consegna, basata sull'affidabilità di \textcolor{Bittersweet}{TCP}. 
Ma il mittente non può spedire il messaggio se il processo sul destinatario non è attivo, quindi non rappresenta un'implementazione realizzabile. Inoltre il mittente si deve ricordare il nome della macchina del destinatario, può essere il nome del \textcolor{Mahogany}{DNS} o dell'indirizzo \textcolor{Bittersweet}{IP}, ma questo deve essere noto per poter instaurare la connessione. 
Questo stesso approccio non è ragionevole per molti servizi basati sulle reti. Inoltre non viene definito come il destinatario viene autenticato, poiché viene riconosciuto solamente dalla macchina. 

Si considera quindi una variante dove un \textit{server} intermedio disaccoppia le due macchine \textit{host}, questo \textit{server} rappresenta il dominio del destinatario, ovvero un nodo dell'albero del namespace. 
Si ipotizza di legare i destinatari a domini di \textit{internet}, sotto qualche forma. Questo \textit{server} di ricezione deve essere ben noto. 
I processi di invio e ricezione sono disaccoppiati, ed il destinatario può essere autenticato dal \textit{server}, dove sono presenti servizi di autenticazione. Il mittente non deve ricordare la specifica macchina del destinatario, ma solamente il dominio. 
Ma questo \textit{server} può essere impegnato, guasto o sovraccarico in un certo istante e questo non garantisce di ricevere il messaggio dal \textit{server}. Se dopo aver inviato il messaggio il processo del mittente può essere chiuso e quindi il messaggio non è in grado di arrivare al \textit{server}. Poiché non si ha autorità sulla gestione del \textit{server}. 

L'architettura moderna contiene un serve mittente per memorizzare il messaggio, con funzione di inoltro, e molti \textit{server} duplicati, definendone uno primario ed altri 
ausiliari. In questo modo se il primo \textit{server} non è raggiungibile si può tentare di raggiungere uno dei \textit{server} primari, per inoltrare il messaggio al destinatario. 

Questa rappresenta un'architettura diversa da quella che \textcolor{Emerald}{is} potrebbe aspettare. Bisogna quindi specificare come si definiscono indirizzi di posta elettronica, in rifermento a questa architettura. Una prima parte dell'indirizzo identifica un'entità che riceve il messaggio, ed una seconda parte per definire il dominio dell utente, dopo un \verb|@|, per ricavare il \textit{server} che deve ricevere il messaggio. 

La prima applicazione coinvolta nel servizio si chiama MUA, ``Mail User Agent'' e viene mandato in esecuzione quando si vuole accedere al servizio di posta elettronica. L'utente può chiudere questa applicazione quando lo ritiene opportuno e viene chiamata anche mailer. 
L'applicazione MTA, ``Mail Transmission Agent'', al contrario della MUA, il MTA è accessibile in modo stabile nle tempo, poiché si trova su di un \textit{server} di inoltro per permettere al messaggio di essere trasmesso da una sorgente ad una destinazione. 

Esempi di MUA sono applicazioni Desktop come Mozilla Thunderbird o Microsoft Outlook, altri servizi si basano sul web che trasformano il browser in un MUA, come Gmail, a cui bisogna però autenticarsi sul browser. Sono inoltre disponibili molte applicazioni mobile Android ed iOS. 

MUA e MTA sono applicazioni, che vengono eseguite su delle macchine, quelle che ospitano gli MTA sono dei \textit{server} che possono avere diversi ruoli nell'architettura appena definita. Un primo tipo di \textit{server} si chiama OMS, ``Outgoing Main Server'', alla quale MTA si riferisce direttamente il processo MUA del mittente. 
Un \textit{server} di tipo ``Mail eXchanger'', per ogni dominio \textcolor{Mahogany}{DNS} infatti esiste una lista di \textit{host}, in ordine di priorità che ospitano gli MTA incaricati di ricevere posta per quel dominio. 
Un ulteriore \textit{server} chiamato ``Incoming Mail Server'' è il serve che contiene la MTA che comunica direttamente con la MUA del destinatario, generalmente coincide con il Mail eXchanger primario del dominio. 

Si vuole che l'utente possa configurare facilmente il servizio della posta elettronica. In quest'architettura l'utente deve ricordarsi semplicemente due \textit{server}, il suo MUA si riferisce infatti ad un Outgoing Mail Server ed un Incoming Mail Server. Questi \textit{server} invece di specificarli con un indirizzo \textcolor{Bittersweet}{IP} si possono specificare con un nome, in modo che se dovesse cambiare l'indirizzo \textcolor{Bittersweet}{IP} della macchina non sarebbe necessario modificare il servizio. 

Le MTA ospitate sull'Outgoing Mail Server sono suddivise in due processi chiamate MSA, ``Message Submission Agent'', quello a cui si rivolge la MUA per spedire la posta, ed il secondo è il vero e proprio MTA che cura la spedizione al MTA del dominio del destinatario. Lo stesso avviene per un IMS, dove esiste sempre un processo MTA, ed un ulteriore processo MDA, ``Mail Delivery Agent'', responsabile del recapito all'utente. 


Definita l'architettura si definiscono una serie di azioni, a più livelli di dettaglio, scomposte in varie operazioni. Tutte le primitive di gestione dei messaggi in partenza e dei messaggi ricevuti 
sono delegati al MUA. Quando l'utente richiede il salvataggio della MUA, quando l'utente richiede il salvataggio del messaggio, il MUA accede al \textit{file} system locale, per salvare la nuova mail, in caso non esista, accodandola al \textit{file} delle mail salvate, con il rispettivo testo. 

Quando si spedisce un messaggio il MUA invia il messaggio al suo OMS, che cerca il Mail eXchanger del dominio del destinatario utilizzando il \textcolor{Mahogany}{DNS}, se il primario non è disponibile si rivolge al secondario, richiedendo al proprio serve primario la lista dei MX del dominio destinazione, in ordine di priorità, tentando di trasmettere il messaggio ad intervalli regolari. Se fallisce per tre giorni consecutivi viene notificato l'utente del fallimento. Se viene inviato ad un MX secondario, questo tenta ad intervalli regolari di inviare i messaggi salvati al MX primario. 

Sono presenti anche servizi ausiliari, ovvero il \textcolor{Mahogany}{DNS}, senza il quale la posta elettronica non funzionerebbe, inoltre è necessario un File System distribuito, il \textit{server} deve poter accedere ai \textit{file} delle mail tramite un sistema per il File System distribuito, poiché potrebbero non trovarsi sullo stesso \textit{server}. 

Esiste un comando chiamato \verb|dig| che permette, sulle macchine Linux, di comportarsi come resolver, nel mondo Windows è presente un comando analogo chiamato \verb|nslookup|, che fornisce record MX. In questo modo è possibile ottenere le informazioni relative ai \textit{server} ed i loro indirizzi \textcolor{BurntOrange}{IPv4}. Utilizzando questo comando bisogna specificare ulteriori parametri per leggere i record MX, e specificare l'indirizzo. Questo va effettuato anche con il comando \verb|dig| specificando dopo la flag \verb|-f| il tipo di record che si vuole leggere e l'indirizzo corrispondente. 


Dato un MUA configurato per spedire mail bisogna conoscere l'indirizzo \textcolor{Bittersweet}{IP} dell'OMS, questo si ottiene specificando un nome ed invocando un \textcolor{Mahogany}{DNS}, questo effettua la risoluzione dell'indirizzo, e rappresenti il primo punto di contatto tra la posta elettronica ed il \textcolor{Mahogany}{DNS}, mentre un punto di contatto diverso rappresenta l'OMS che notifica al \textcolor{Mahogany}{DNS} di voler conoscere l'indirizzo MX del destinatario. Questa seconda operazione infatti non rappresenta una risoluzione canonica. Il messaggio viene inviato dall'OMS al MX relativo all'IMS del destinatario. 
Il MX e l'IMS comunicano tra di loro tramite una memoria di massa condivisa sulla quale può scrivere il MX e leggere l'IMS. 


Si possono distinguere due tipi di flussi di informazione, tra il primo MUA e l'MTA dell'OMS, che si trasmettono messaggi fino a quando non arrivano al MX primario del destinatario. 
Questo primo flusso di informazione è realizzato da un \textit{client} che intende trasferire uno o più messaggi, tramite un servizio che il \textit{server} potrebbe accettare o rifiutare di concedere il servizio. 
Non occorre autenticare gli interlocutori poiché o entrambi hanno i privilegi di amministratore, oppure uno di essi non è il mittente, e non si considera cruciale assicurarsi che il mittente corrisponda a quanto dichiarato. Poiché l'IMS ed il MX sono due macchine associate a compagnie diverse e non sarebbe realizzabile permettere a tutti i possibili OMS le autenticazioni del \textit{server} MX, analogamente per il riferimento ad utenti che inviano messaggi da spedire ai proprio OMS. 
Si suppone non ci sia una verifica di autenticazione in questo passaggio, e questo è la causa dello spam che invade la posta elettronica. 


Mentre l'ultimo passaggio dall'IMS dal destinatario probabilmente è realizzato da un'interazione di richieste e risposte, e sembra essere intrinsecamente più complicato. Utilizza quindi un protocollo più articolato. 
Il \textit{client} si informa sul numero e la dimensione dei messaggi contenuti nel \textit{server}, e destinati allo specifico utente. In questo passaggio l'autenticazione è indispensabile, e si possono trasferire o non trasferire messaggi. 
Chi utilizza questi messaggi si deve autenticare poiché consente di leggere solo i messaggi espressamente indirizzati all'utente con le opportune credenziali. 

\end{document}